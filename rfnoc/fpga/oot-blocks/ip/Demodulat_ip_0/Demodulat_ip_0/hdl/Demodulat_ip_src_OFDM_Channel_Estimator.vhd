-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/genhdlOFDMDemodulatorChEstModel/Demodulat_ip_src_OFDM_Channel_Estimator.vhd
-- Created: 2025-12-04 17:31:13
-- 
-- Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Demodulat_ip_src_OFDM_Channel_Estimator
-- Source Path: genhdlOFDMDemodulatorChEstModel/Demodulation and Channel Estimation/HDL Algorithm/OFDM Channel Estimator
-- Hierarchy Level: 2
-- Model version: 8.101
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Demodulat_ip_src_Demodulation_and_Channel_Estimation_pkg.ALL;

ENTITY Demodulat_ip_src_OFDM_Channel_Estimator IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        In1_re                            :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        In1_im                            :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        In2                               :   IN    std_logic;
        In3_re                            :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        In3_im                            :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        In4                               :   IN    std_logic;
        numSCPS                           :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        reset_1                           :   IN    std_logic;
        Out1_re                           :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        Out1_im                           :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        Out2                              :   OUT   std_logic
        );
END Demodulat_ip_src_OFDM_Channel_Estimator;


ARCHITECTURE rtl OF Demodulat_ip_src_OFDM_Channel_Estimator IS

  -- Component Declarations
  COMPONENT Demodulat_ip_src_SimpleDualPortRAM_generic_block
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din_re                       :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_din_im                       :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout_re                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          dout_im                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT Demodulat_ip_src_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Demodulat_ip_src_SimpleDualPortRAM_generic_block
    USE ENTITY work.Demodulat_ip_src_SimpleDualPortRAM_generic_block(rtl);

  FOR ALL : Demodulat_ip_src_SimpleDualPortRAM_generic
    USE ENTITY work.Demodulat_ip_src_SimpleDualPortRAM_generic(rtl);

  -- Signals
  SIGNAL Constant1_out1                   : std_logic;
  SIGNAL Constant_out1                    : std_logic;
  SIGNAL out_rsvd                         : std_logic;
  SIGNAL Data_Type_Conversion_out1        : std_logic;
  SIGNAL out_rsvd_1                       : std_logic;
  SIGNAL Logical_Operator_out1            : std_logic;
  SIGNAL Delay3_reg                       : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay3_out1                      : std_logic;
  SIGNAL Constant_out1_re                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant_out1_im                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL In1_re_signed                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL In1_im_signed                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL out_re                           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL out_im                           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant1_out1_re                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant1_out1_im                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Add_out1_re                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Add_out1_im                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay_reg_re                     : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay_reg_im                     : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay_out1_re                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay_out1_im                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_C2ReIm_1_C2ReIm_A        : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL In3_re_signed                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL In3_im_signed                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL dataOut_re                       : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL dataOut_im                       : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL conj_cast                        : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL conj_cast_1                      : signed(16 DOWNTO 0);  -- sfix17_En14
  SIGNAL Conjugate_out1_re                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Conjugate_out1_im                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay1_reg_re                    : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay1_reg_im                    : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay1_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay1_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_C2ReIm_1_C2ReIm_B        : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_Re_AC                    : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Product_Re_AC_1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_Re_BD                    : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Product_Re_BD_1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL mulOutput                        : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_Im_AD                    : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Product_Im_AD_1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_Im_BC                    : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Product_Im_BC_1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL mulOutput_1                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay2_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay2_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay6_reg_re                    : vector_of_signed16(0 TO 2);  -- sfix16_En14 [3]
  SIGNAL Delay6_reg_im                    : vector_of_signed16(0 TO 2);  -- sfix16_En14 [3]
  SIGNAL Delay6_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay6_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL out_rsvd_2                       : std_logic;
  SIGNAL out_rsvd_3                       : std_logic;
  SIGNAL Delay_reg                        : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay_out1                       : std_logic;
  SIGNAL Logical_Operator6_out1           : std_logic;
  SIGNAL Delay9_out1                      : std_logic;
  SIGNAL Delay1_reg                       : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Delay1_out1                      : std_logic;
  SIGNAL Delay2_reg                       : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay2_out1                      : std_logic;
  SIGNAL Logical_Operator5_out1           : std_logic;
  SIGNAL count_step                       : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL count_from                       : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL count_reset                      : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL numSCPS_unsigned                 : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL out_rsvd_4                       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Delay10_reg                      : vector_of_unsigned16(0 TO 2);  -- ufix16 [3]
  SIGNAL Delay10_out1                     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Data_Type_Conversion3_out1       : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Constant12_out1                  : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL count_step_1                     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL count_from_1                     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL count_reset_1                    : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL AvgSymbCount_out1                : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL count                            : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL need_to_wrap                     : std_logic;
  SIGNAL count_value                      : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Compare_To_Constant1_out1        : std_logic;
  SIGNAL SubScCount_out1                  : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL Compare_To_Constant4_out1        : std_logic;
  SIGNAL Logical_Operator5_out1_1         : std_logic;
  SIGNAL numScPerSymOut                   : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL numValidScPerSym                 : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL numValidScPerSym_next            : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Compare_To_Constant5_out1        : std_logic;
  SIGNAL Switch6_out1                     : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL count_1                          : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL need_to_wrap_1                   : std_logic;
  SIGNAL count_value_1                    : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL count_2                          : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL AND_out1                         : std_logic;
  SIGNAL Logical_Operator3_out1           : std_logic;
  SIGNAL count_3                          : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL Relational_Operator_relop1       : std_logic;
  SIGNAL count_4                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL count_5                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL ScCountDelay_out1                : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Constant11_out1                  : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Add3_out1                        : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL Logical_Operator_out1_1          : std_logic;
  SIGNAL dataDelay1_out1                  : std_logic;
  SIGNAL dataDelay_out1                   : std_logic;
  SIGNAL Logical_Operator4_out1           : std_logic;
  SIGNAL Logical_Operator1_out1           : std_logic;
  SIGNAL Delay4_reg                       : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay4_out1                      : std_logic;
  SIGNAL Delay4_out1_1                    : std_logic;
  SIGNAL Constant_out1_re_1               : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Constant_out1_im_1               : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Constant_out1_dtc_re             : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant_out1_dtc_im             : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL out_rsvd_5                       : std_logic;
  SIGNAL Logical_Operator6_out1_1         : std_logic;
  SIGNAL Delay9_out1_1                    : std_logic;
  SIGNAL Delay9_out1_2                    : std_logic;
  SIGNAL Delay1_reg_1                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Delay1_out1_1                    : std_logic;
  SIGNAL Delay1_out1_2                    : std_logic;
  SIGNAL Delay2_reg_1                     : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay2_out1_1                    : std_logic;
  SIGNAL Delay2_out1_2                    : std_logic;
  SIGNAL Logical_Operator5_out1_2         : std_logic;
  SIGNAL Delay2_out1_3                    : std_logic;
  SIGNAL Constant2_out1_re                : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Constant2_out1_im                : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL dataOut_re_1                     : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL dataOut_im_1                     : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Delay4_out1_re                   : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Delay4_out1_im                   : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Switch_out1_re_1                 : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Switch_out1_im_1                 : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Compare_To_Constant3_out1        : std_logic;
  SIGNAL Logical_Operator2_out1           : std_logic;
  SIGNAL SCAndSymb_Indicator_out2         : std_logic;
  SIGNAL Delay1_out1_3                    : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL Delay1_out1_4                    : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL Delay5_out1                      : std_logic;
  SIGNAL dataValidDelay                   : std_logic;
  SIGNAL Logical_Operator_out1_2          : std_logic;
  SIGNAL Constant13_out1                  : std_logic;
  SIGNAL Switch8_out1                     : std_logic;
  SIGNAL SCAndSymb_Indicator_out1         : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL Constant1_out1_re_1              : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Constant1_out1_im_1              : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Accumulator_RAM_out1_im          : std_logic_vector(28 DOWNTO 0);  -- ufix29
  SIGNAL Accumulator_RAM_out1_im_signed   : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Add_out1_im_1                    : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Add_out1_re_1                    : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Accumulator_RAM_out1_re          : std_logic_vector(28 DOWNTO 0);  -- ufix29
  SIGNAL Accumulator_RAM_out1_re_signed   : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Switch7_out1_re                  : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Switch7_out1_im                  : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Delay1_reg_re_1                  : vector_of_signed29(0 TO 1);  -- sfix29_En14 [2]
  SIGNAL Delay1_reg_im_1                  : vector_of_signed29(0 TO 1);  -- sfix29_En14 [2]
  SIGNAL Delay1_out1_re_1                 : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Delay1_out1_im_1                 : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Constant1_out1_1                 : unsigned(11 DOWNTO 0);  -- ufix12
  SIGNAL Constant_out1_1                  : unsigned(11 DOWNTO 0);  -- ufix12
  SIGNAL Switch2_out1                     : unsigned(11 DOWNTO 0);  -- ufix12
  SIGNAL Constant2_out1                   : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Add2_out1                        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Counter_RAM_out1                 : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL Counter_RAM_out1_unsigned        : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Switch3_out1                     : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Out_value                        : unsigned(16 DOWNTO 0);  -- ufix17_En16
  SIGNAL Delay2_reg_2                     : vector_of_unsigned17(0 TO 1);  -- ufix17 [2]
  SIGNAL Delay2_out1_4                    : unsigned(16 DOWNTO 0);  -- ufix17_En16
  SIGNAL Product1_cast                    : signed(17 DOWNTO 0);  -- sfix18_En16
  SIGNAL Product1_mul_temp                : signed(46 DOWNTO 0);  -- sfix47_En30
  SIGNAL Product1_Re                      : signed(45 DOWNTO 0);  -- sfix46_En30
  SIGNAL Product1_Re_1                    : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Product11_cast                   : signed(17 DOWNTO 0);  -- sfix18_En16
  SIGNAL Product11_mul_temp               : signed(46 DOWNTO 0);  -- sfix47_En30
  SIGNAL Product1_Im                      : signed(45 DOWNTO 0);  -- sfix46_En30
  SIGNAL Product1_Im_1                    : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Delay3_out1_re                   : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Delay3_out1_im                   : signed(28 DOWNTO 0);  -- sfix29_En14
  SIGNAL Delay3_out1_dtc_re               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay3_out1_dtc_im               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_re_2                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_im_2                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_re_3                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_im_3                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay4_reg_re                    : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay4_reg_im                    : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay4_out1_re_1                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay4_out1_im_1                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant4_out1                   : std_logic;
  SIGNAL Delay3_reg_1                     : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay3_out1_1                    : std_logic;
  SIGNAL Switch4_out1                     : std_logic;
  SIGNAL out_rsvd_6                       : std_logic;
  SIGNAL Logical_Operator6_out1_2         : std_logic;
  SIGNAL Delay9_out1_3                    : std_logic;
  SIGNAL Delay1_reg_2                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Delay1_out1_5                    : std_logic;
  SIGNAL Delay2_reg_3                     : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay2_out1_5                    : std_logic;
  SIGNAL Logical_Operator5_out1_3         : std_logic;
  SIGNAL count_step_2                     : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL count_from_2                     : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL count_reset_2                    : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL Constant5_out1                   : std_logic;
  SIGNAL Constant1_out1_2                 : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Add1_out1                        : unsigned(11 DOWNTO 0);  -- ufix12
  SIGNAL Delay9_reg                       : vector_of_unsigned16(0 TO 2);  -- ufix16 [3]
  SIGNAL Delay9_out1_4                    : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Delay8_reg                       : vector_of_unsigned12(0 TO 2);  -- ufix12 [3]
  SIGNAL Delay8_out1                      : unsigned(11 DOWNTO 0);  -- ufix12
  SIGNAL Delay8_out1_dtc                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Switch5_out1                     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Data_Type_Conversion3_out1_1     : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Constant12_out1_1                : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL numSCPS_Counter_out1             : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL count_6                          : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL need_to_wrap_2                   : std_logic;
  SIGNAL count_value_2                    : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL count_7                          : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL Switch6_out1_1                   : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Add1_sub_cast                    : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add1_sub_cast_1                  : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add1_out1_1                      : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Compare_To_Constant3_out1_1      : std_logic;
  SIGNAL Logical_Operator2_out1_1         : std_logic;
  SIGNAL Logical_Operator4_out1_1         : std_logic;
  SIGNAL count_8                          : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL Compare_To_Zero1_out1            : std_logic;
  SIGNAL Logical_Operator5_out1_4         : std_logic;
  SIGNAL numScPerSymOut_1                 : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL numValidScPerSym_1               : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL numValidScPerSym_next_1          : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Delay_out1_1                     : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL Compare_To_Constant5_out1_1      : std_logic;
  SIGNAL numScPerSym                      : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL Data_Valid_Reset_out1            : std_logic;
  SIGNAL NumSCPerSym_Generator_out4       : std_logic;
  SIGNAL Constant2_out1_1                 : std_logic;
  SIGNAL AvgDone                          : std_logic;
  SIGNAL Compare_To_Constant1_out1_1      : std_logic;
  SIGNAL Logical_Operator3_out1_1         : std_logic;
  SIGNAL Delay5_reg                       : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay5_out1_1                    : std_logic;
  SIGNAL Constant9_out1                   : std_logic;
  SIGNAL Delay7_reg                       : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay7_out1                      : std_logic;
  SIGNAL Constant8_out1                   : std_logic;
  SIGNAL Switch4_out1_1                   : std_logic;
  SIGNAL Switch2_out1_1                   : std_logic;
  SIGNAL Logical_Operator6_out1_3         : std_logic;
  SIGNAL Delay9_out1_5                    : std_logic;
  SIGNAL Delay9_out1_6                    : std_logic;
  SIGNAL Delay1_reg_3                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Delay1_out1_6                    : std_logic;
  SIGNAL Delay1_out1_7                    : std_logic;
  SIGNAL Delay2_reg_4                     : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay2_out1_6                    : std_logic;
  SIGNAL Delay2_out1_7                    : std_logic;
  SIGNAL Logical_Operator5_out1_5         : std_logic;
  SIGNAL Constant4_out1_1                 : std_logic;
  SIGNAL count_step_3                     : std_logic;  -- ufix1
  SIGNAL count_from_3                     : std_logic;  -- ufix1
  SIGNAL count_reset_3                    : std_logic;  -- ufix1
  SIGNAL first_bin_flag_indicator_out1    : std_logic;  -- ufix1
  SIGNAL count_9                          : std_logic;  -- ufix1
  SIGNAL need_to_wrap_3                   : std_logic;
  SIGNAL count_value_3                    : std_logic;  -- ufix1
  SIGNAL Compare_To_Zero_out1             : std_logic;
  SIGNAL Logical_Operator_out1_3          : std_logic;
  SIGNAL Switch1_out1                     : std_logic;
  SIGNAL count_10                         : std_logic;  -- ufix1
  SIGNAL count_11                         : std_logic;  -- ufix1
  SIGNAL Switch2_out1_2                   : std_logic;
  SIGNAL count_step_4                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL count_from_4                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL Constant5_out1_1                 : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL count_reset_4                    : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL InterpPointsSampCount_out1       : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL count_12                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL need_to_wrap_4                   : std_logic;
  SIGNAL count_value_4                    : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL count_13                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL count_14                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL count_15                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL Compare_To_Constant_out1_1       : std_logic;
  SIGNAL Switch3_out1_1                   : std_logic;
  SIGNAL Logical_Operator3_out1_2         : std_logic;
  SIGNAL Compare_To_Constant1_out1_2      : std_logic;
  SIGNAL Logical_Operator1_out1_1         : std_logic;
  SIGNAL EndOfFirstBin                    : std_logic;
  SIGNAL ScCounter                        : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL interpFacOut                     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL interpFac                        : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL Data1Out_re                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data1Out_im                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data2Out_re                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data2Out_im                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL posOfFirstHighRef_1              : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL initExtrapValidOut               : std_logic;
  SIGNAL posOfFirstHighRefBuff            : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL intermediateBuff_re              : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL intermediateBuff_im              : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp1_re                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp1_im                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp2_re                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp2_im                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL posOfFirstHighRefBuff_next       : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL intermediateBuff_next_re         : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL intermediateBuff_next_im         : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp1_next_re                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp1_next_im                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp2_next_re                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL interInp2_next_im                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL initExtrapValidOut_1             : std_logic;
  SIGNAL initExtrapValidOut_last_value    : std_logic;
  SIGNAL stateControl_4                   : std_logic;
  SIGNAL stateControl_5                   : std_logic;
  SIGNAL enb_gated_1                      : std_logic;
  SIGNAL HDL_Counter_ctrl_const_out       : std_logic;
  SIGNAL HDL_Counter_ctrl_delay_out       : std_logic;
  SIGNAL HDL_Counter_Initial_Val_out      : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Constant2_out1_2                 : std_logic;
  SIGNAL Constant2_out1_3                 : std_logic;
  SIGNAL count_step_5                     : std_logic;  -- ufix1
  SIGNAL count_from_5                     : std_logic;  -- ufix1
  SIGNAL count_reset_5                    : std_logic;  -- ufix1
  SIGNAL Logical_Operator_out1_4          : std_logic;
  SIGNAL Constant5_out1_2                 : std_logic;
  SIGNAL Constant5_out1_3                 : std_logic;
  SIGNAL Constant4_out1_2                 : std_logic;
  SIGNAL Constant4_out1_3                 : std_logic;
  SIGNAL count_step_6                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_from_6                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Constant_out1_2                  : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_reset_6                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_step_7                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_from_7                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_reset_7                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL HDL_Counter1_out1                : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_16                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL need_to_wrap_5                   : std_logic;
  SIGNAL count_value_5                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL HDL_Counter_out1                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_17                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL need_to_wrap_6                   : std_logic;
  SIGNAL count_value_6                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL binary_counter_out1              : std_logic;  -- ufix1
  SIGNAL Compare_To_Constant3_out1_2      : std_logic;
  SIGNAL Compare_To_Constant2_out1        : std_logic;
  SIGNAL Logical_Operator1_out1_2         : std_logic;
  SIGNAL Switch4_out1_2                   : std_logic;
  SIGNAL Logical_Operator_out1_5          : std_logic;
  SIGNAL Switch1_out1_1                   : std_logic;
  SIGNAL count_18                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_19                         : std_logic;  -- ufix1
  SIGNAL need_to_wrap_7                   : std_logic;
  SIGNAL count_value_7                    : std_logic;  -- ufix1
  SIGNAL Switch_out1                      : std_logic;
  SIGNAL count_20                         : std_logic;  -- ufix1
  SIGNAL Logical_Operator6_out1_4         : std_logic;
  SIGNAL count_21                         : std_logic;  -- ufix1
  SIGNAL Compare_To_Constant_out1_2       : std_logic;
  SIGNAL count_22                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_23                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL HDL_Counter_out                  : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Compare_To_Constant1_out1_3      : std_logic;
  SIGNAL Logical_Operator2_out1_2         : std_logic;
  SIGNAL count_24                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Compare_To_Constant5_out1_2      : std_logic;
  SIGNAL count_25                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Constant8_out1_1                 : std_logic;
  SIGNAL CmpIPF_out1                      : std_logic;
  SIGNAL CmpIPF_out1_1                    : std_logic;
  SIGNAL Switch4_out1_3                   : std_logic;
  SIGNAL Constant1_out1_3                 : std_logic;
  SIGNAL Constant1_out1_4                 : std_logic;
  SIGNAL count_step_8                     : std_logic;  -- ufix1
  SIGNAL count_from_8                     : std_logic;  -- ufix1
  SIGNAL count_reset_8                    : std_logic;  -- ufix1
  SIGNAL binary_counter1_out1             : std_logic;  -- ufix1
  SIGNAL count_26                         : std_logic;  -- ufix1
  SIGNAL need_to_wrap_8                   : std_logic;
  SIGNAL count_value_8                    : std_logic;  -- ufix1
  SIGNAL Compare_To_Constant4_out1_1      : std_logic;
  SIGNAL Logical_Operator3_out1_3         : std_logic;
  SIGNAL Switch3_out1_2                   : std_logic;
  SIGNAL count_27                         : std_logic;  -- ufix1
  SIGNAL count_28                         : std_logic;  -- ufix1
  SIGNAL Switch2_out1_3                   : std_logic;
  SIGNAL Constant_out1_3                  : std_logic;
  SIGNAL Constant_out1_4                  : std_logic;
  SIGNAL count_step_9                     : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL count_from_9                     : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL count_reset_9                    : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL numSCPSOutCounter_out1           : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL count_29                         : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL need_to_wrap_9                   : std_logic;
  SIGNAL count_value_9                    : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL Add_sub_cast                     : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add_sub_cast_1                   : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add_out1                         : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Compare_To_Constant6_out1        : std_logic;
  SIGNAL Logical_Operator4_out1_2         : std_logic;
  SIGNAL finalExtrapValidOut              : std_logic;
  SIGNAL FinalExtrapRepBuff               : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL FinalExtrapRepBuff_next          : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL finalExtrapValidOut_1            : std_logic;
  SIGNAL finalExtrapValidOut_last_value   : std_logic;
  SIGNAL finalExtrapValidOut_2            : std_logic;
  SIGNAL Logical_Operator5_out1_6         : std_logic;
  SIGNAL Logical_Operator2_out1_3         : std_logic;
  SIGNAL Compare_To_Constant3_out1_3      : std_logic;
  SIGNAL Switch1_out1_2                   : std_logic;
  SIGNAL count_30                         : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL Add1_sub_cast_2                  : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add1_sub_cast_3                  : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Add1_out1_2                      : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Logical_Operator3_out1_4         : std_logic;
  SIGNAL count_31                         : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL posOfFirstHighRef_2              : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL posOfFirstHighRef_last_value     : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL Add_sub_cast_2                   : signed(13 DOWNTO 0);  -- sfix14
  SIGNAL Add_sub_cast_3                   : signed(13 DOWNTO 0);  -- sfix14
  SIGNAL Add_out1_1                       : signed(13 DOWNTO 0);  -- sfix14
  SIGNAL stateControl_7                   : std_logic;
  SIGNAL stateControl_8                   : std_logic;
  SIGNAL enb_gated_2                      : std_logic;
  SIGNAL Delay1_reg_4                     : vector_of_signed14(0 TO 5);  -- sfix14 [6]
  SIGNAL Delay1_out1_8                    : signed(13 DOWNTO 0);  -- sfix14
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Constant4_out1_re                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant4_out1_im                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant4_out1_re_1              : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant4_out1_im_1              : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data2Out_re_1                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data2Out_im_1                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data2Out_last_value_re           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data2Out_last_value_im           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch3_out1_re                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch3_out1_im                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL stateControl_9                   : std_logic;
  SIGNAL stateControl_10                  : std_logic;
  SIGNAL enb_gated_3                      : std_logic;
  SIGNAL Delay2_reg_re                    : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay2_reg_im                    : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay2_out1_re_1                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay2_out1_im_1                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Compare_To_Constant7_out1        : std_logic;
  SIGNAL Logical_Operator7_out1           : std_logic;
  SIGNAL Constant6_out1                   : std_logic;
  SIGNAL Constant6_out1_1                 : std_logic;
  SIGNAL count_step_10                    : std_logic;  -- ufix1
  SIGNAL count_from_10                    : std_logic;  -- ufix1
  SIGNAL count_reset_10                   : std_logic;  -- ufix1
  SIGNAL binary_counter2_out1             : std_logic;  -- ufix1
  SIGNAL count_32                         : std_logic;  -- ufix1
  SIGNAL need_to_wrap_10                  : std_logic;
  SIGNAL count_value_10                   : std_logic;  -- ufix1
  SIGNAL Switch7_out1                     : std_logic;
  SIGNAL count_33                         : std_logic;  -- ufix1
  SIGNAL count_34                         : std_logic;  -- ufix1
  SIGNAL stateControl_12                  : std_logic;
  SIGNAL stateControl_13                  : std_logic;
  SIGNAL enb_gated_4                      : std_logic;
  SIGNAL Delay1_reg_5                     : std_logic_vector(5 DOWNTO 0);  -- ufix1 [6]
  SIGNAL Delay1_out1_9                    : std_logic;  -- ufix1
  SIGNAL Constant3_out1_re                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant3_out1_im                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant3_out1_re_1              : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant3_out1_im_1              : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch5_out1_re                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch5_out1_im                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL stateControl_14                  : std_logic;
  SIGNAL stateControl_15                  : std_logic;
  SIGNAL enb_gated_5                      : std_logic;
  SIGNAL Delay4_reg_re_1                  : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay4_reg_im_1                  : vector_of_signed16(0 TO 5);  -- sfix16_En14 [6]
  SIGNAL Delay4_out1_re_2                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay4_out1_im_2                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL down_counter_ctrl_const_out      : std_logic;
  SIGNAL down_counter_ctrl_delay_out      : std_logic;
  SIGNAL down_counter_Initial_Val_out     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_step_11                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_from_11                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_reset_11                   : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL down_counter_out1                : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_35                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL need_to_wrap_11                  : std_logic;
  SIGNAL count_value_11                   : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_36                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_37                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL down_counter_out                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL stateControl_16                  : std_logic;
  SIGNAL stateControl_17                  : std_logic;
  SIGNAL enb_gated_6                      : std_logic;
  SIGNAL Delay3_reg_2                     : vector_of_unsigned3(0 TO 1);  -- ufix3 [2]
  SIGNAL Delay3_out1_2                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Data1Out_re_1                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data1Out_im_1                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data1Out_last_value_re           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data1Out_last_value_im           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL stateControl_18                  : std_logic;
  SIGNAL stateControl_19                  : std_logic;
  SIGNAL enb_gated_7                      : std_logic;
  SIGNAL Delay4_reg_re_2                  : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay4_reg_im_2                  : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay4_out1_re_3                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay4_out1_im_3                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Product_cast                     : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL Product_mul_temp                 : signed(19 DOWNTO 0);  -- sfix20_En14
  SIGNAL Product_cast_1                   : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL Product_mul_temp_1               : signed(19 DOWNTO 0);  -- sfix20_En14
  SIGNAL Product_out1_re                  : signed(18 DOWNTO 0);  -- sfix19_En14
  SIGNAL Product_out1_im                  : signed(18 DOWNTO 0);  -- sfix19_En14
  SIGNAL stateControl_20                  : std_logic;
  SIGNAL stateControl_21                  : std_logic;
  SIGNAL enb_gated_8                      : std_logic;
  SIGNAL Delay7_out1_re                   : signed(18 DOWNTO 0);  -- sfix19_En14
  SIGNAL Delay7_out1_im                   : signed(18 DOWNTO 0);  -- sfix19_En14
  SIGNAL stateControl_22                  : std_logic;
  SIGNAL stateControl_23                  : std_logic;
  SIGNAL enb_gated_9                      : std_logic;
  SIGNAL Delay5_reg_re                    : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay5_reg_im                    : vector_of_signed16(0 TO 1);  -- sfix16_En14 [2]
  SIGNAL Delay5_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay5_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant1_out1_5                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Constant1_out1_6                 : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_step_12                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_from_12                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_reset_12                   : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL up_counter_out1                  : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_38                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL need_to_wrap_12                  : std_logic;
  SIGNAL count_value_12                   : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_39                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL count_40                         : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Add1_out1_3                      : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL stateControl_24                  : std_logic;
  SIGNAL stateControl_25                  : std_logic;
  SIGNAL enb_gated_10                     : std_logic;
  SIGNAL Delay6_reg                       : vector_of_unsigned4(0 TO 1);  -- ufix4 [2]
  SIGNAL Delay6_out1                      : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Product1_cast_1                  : signed(4 DOWNTO 0);  -- sfix5
  SIGNAL Product1_mul_temp_1              : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Product1_cast_2                  : signed(4 DOWNTO 0);  -- sfix5
  SIGNAL Product1_mul_temp_2              : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Product1_out1_re                 : signed(19 DOWNTO 0);  -- sfix20_En14
  SIGNAL Product1_out1_im                 : signed(19 DOWNTO 0);  -- sfix20_En14
  SIGNAL stateControl_26                  : std_logic;
  SIGNAL stateControl_27                  : std_logic;
  SIGNAL enb_gated_11                     : std_logic;
  SIGNAL Delay8_out1_re                   : signed(19 DOWNTO 0);  -- sfix20_En14
  SIGNAL Delay8_out1_im                   : signed(19 DOWNTO 0);  -- sfix20_En14
  SIGNAL Add_add_cast                     : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Add_add_cast_1                   : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Add_add_cast_2                   : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Add_add_cast_3                   : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Add_out1_re_2                    : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Add_out1_im_2                    : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL stateControl_29                  : std_logic;
  SIGNAL stateControl_30                  : std_logic;
  SIGNAL enb_gated_12                     : std_logic;
  SIGNAL Delay_reg_re_1                   : vector_of_signed21(0 TO 1);  -- sfix21_En14 [2]
  SIGNAL Delay_reg_im_1                   : vector_of_signed21(0 TO 1);  -- sfix21_En14 [2]
  SIGNAL Delay_out1_re_1                  : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Delay_out1_im_1                  : signed(20 DOWNTO 0);  -- sfix21_En14
  SIGNAL Out_value_1                      : unsigned(16 DOWNTO 0);  -- ufix17_En16
  SIGNAL stateControl_31                  : std_logic;
  SIGNAL stateControl_32                  : std_logic;
  SIGNAL enb_gated_13                     : std_logic;
  SIGNAL Delay2_reg_5                     : vector_of_unsigned17(0 TO 4);  -- ufix17 [5]
  SIGNAL Delay2_out1_8                    : unsigned(16 DOWNTO 0);  -- ufix17_En16
  SIGNAL Product2_cast                    : signed(17 DOWNTO 0);  -- sfix18_En16
  SIGNAL Product2_mul_temp                : signed(38 DOWNTO 0);  -- sfix39_En30
  SIGNAL Product2_cast_1                  : signed(17 DOWNTO 0);  -- sfix18_En16
  SIGNAL Product2_mul_temp_1              : signed(38 DOWNTO 0);  -- sfix39_En30
  SIGNAL Product2_out1_re                 : signed(37 DOWNTO 0);  -- sfix38_En30
  SIGNAL Product2_out1_im                 : signed(37 DOWNTO 0);  -- sfix38_En30
  SIGNAL stateControl_33                  : std_logic;
  SIGNAL stateControl_34                  : std_logic;
  SIGNAL enb_gated_14                     : std_logic;
  SIGNAL Delay1_out1_re_2                 : signed(37 DOWNTO 0);  -- sfix38_En30
  SIGNAL Delay1_out1_im_2                 : signed(37 DOWNTO 0);  -- sfix38_En30
  SIGNAL dataOut_re_2                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL dataOut_im_2                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch6_out1_re                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch6_out1_im                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_re_4                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_out1_im_4                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch1_out1_re                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch1_out1_im                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Constant3_out1                   : std_logic;
  SIGNAL Delay1_reg_6                     : std_logic_vector(5 DOWNTO 0);  -- ufix1 [6]
  SIGNAL Delay1_out1_10                   : std_logic;
  SIGNAL stateControl_35                  : std_logic;
  SIGNAL stateControl_36                  : std_logic;
  SIGNAL enb_gated_15                     : std_logic;
  SIGNAL Delay4_reg_1                     : std_logic_vector(5 DOWNTO 0);  -- ufix1 [6]
  SIGNAL Delay4_out1_2                    : std_logic;
  SIGNAL Switch3_out1_3                   : std_logic;
  SIGNAL Logical_Operator6_out1_5         : std_logic;
  SIGNAL Delay9_out1_7                    : std_logic;
  SIGNAL Delay9_out1_8                    : std_logic;
  SIGNAL Delay1_reg_7                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL Delay1_out1_11                   : std_logic;
  SIGNAL Delay1_out1_12                   : std_logic;
  SIGNAL Delay4_reg_2                     : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL Delay4_out1_3                    : std_logic;
  SIGNAL Delay4_out1_4                    : std_logic;
  SIGNAL Delay6_reg_1                     : std_logic_vector(3 DOWNTO 0);  -- ufix1 [4]
  SIGNAL Delay6_out1_1                    : std_logic;
  SIGNAL Delay6_out1_2                    : std_logic;
  SIGNAL Delay7_reg_1                     : std_logic_vector(4 DOWNTO 0);  -- ufix1 [5]
  SIGNAL Delay7_out1_1                    : std_logic;
  SIGNAL Delay7_out1_2                    : std_logic;
  SIGNAL Delay8_reg_1                     : std_logic_vector(5 DOWNTO 0);  -- ufix1 [6]
  SIGNAL Delay8_out1_1                    : std_logic;
  SIGNAL Delay8_out1_2                    : std_logic;
  SIGNAL Logical_Operator5_out1_7         : std_logic;

  ATTRIBUTE use_dsp : string;

  ATTRIBUTE use_dsp OF Product_Re_AC : SIGNAL IS "no";
  ATTRIBUTE use_dsp OF Product_Re_BD : SIGNAL IS "no";
  ATTRIBUTE use_dsp OF Product_Im_AD : SIGNAL IS "no";
  ATTRIBUTE use_dsp OF Product_Im_BC : SIGNAL IS "no";
  ATTRIBUTE use_dsp OF Product1_Re : SIGNAL IS "no";
  ATTRIBUTE use_dsp OF Product1_Im : SIGNAL IS "no";

BEGIN
  -- if numScPerSym is less than 0; numScperSym is taken as 13
  -- Sample numScPerSym when dataValid = 1 and Symbol counter = 0 and Sub carrier Counter = 0
  -- Compare numScperSym and reset Subcarrier Counter
  -- Increment Symbol Counter based on Subcarrier count and average Length (mask)
  -- Subcarrier Counter
  -- Push 0 when Avg is not require
  -- Final Average 
  -- Output
  -- actual RAM output
  -- Add with refData or 0 based on refValid 
  -- Final Counter 
  -- Output
  -- actual RAM output
  -- Push 0 with Avg Start didnt arrive
  -- Add with 1 or 0 based on refValid 

  u_Accumulator_RAM : Demodulat_ip_src_SimpleDualPortRAM_generic_block
    GENERIC MAP( AddrWidth => 13,
                 DataWidth => 29
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din_re => std_logic_vector(Add_out1_re_1),
              wr_din_im => std_logic_vector(Add_out1_im_1),
              wr_addr => std_logic_vector(Delay1_out1_4),
              wr_en => Switch8_out1,
              rd_addr => std_logic_vector(SCAndSymb_Indicator_out1),
              dout_re => Accumulator_RAM_out1_re,
              dout_im => Accumulator_RAM_out1_im
              );

  u_Counter_RAM : Demodulat_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 13,
                 DataWidth => 4
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(Add2_out1),
              wr_addr => std_logic_vector(Delay1_out1_4),
              wr_en => Switch8_out1,
              rd_addr => std_logic_vector(SCAndSymb_Indicator_out1),
              dout => Counter_RAM_out1
              );

  Constant1_out1 <= '1';

  Constant_out1 <= '1';

  out_rsvd <= In2;

  delayMatch4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Data_Type_Conversion_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Data_Type_Conversion_out1 <= out_rsvd;
      END IF;
    END IF;
  END PROCESS delayMatch4_process;


  out_rsvd_1 <= In4;

  Logical_Operator_out1 <= Data_Type_Conversion_out1 AND out_rsvd_1;

  Delay3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay3_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay3_reg(0) <= Logical_Operator_out1;
        Delay3_reg(2 DOWNTO 1) <= Delay3_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay3_process;

  Delay3_out1 <= Delay3_reg(2);

  Constant_out1_re <= to_signed(16#0000#, 16);
  Constant_out1_im <= to_signed(16#0000#, 16);

  In1_re_signed <= signed(In1_re);

  In1_im_signed <= signed(In1_im);

  out_re <= In1_re_signed;
  out_im <= In1_im_signed;

  Constant1_out1_re <= to_signed(16#0000#, 16);
  Constant1_out1_im <= to_signed(16#0000#, 16);

  Add_out1_re <= out_re + Constant1_out1_re;
  Add_out1_im <= out_im + Constant1_out1_im;

  Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_reg_re <= (OTHERS => to_signed(16#0000#, 16));
      Delay_reg_im <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_reg_im(0) <= Add_out1_im;
        Delay_reg_im(1) <= Delay_reg_im(0);
        Delay_reg_re(0) <= Add_out1_re;
        Delay_reg_re(1) <= Delay_reg_re(0);
      END IF;
    END IF;
  END PROCESS Delay_process;

  Delay_out1_re <= Delay_reg_re(1);
  Delay_out1_im <= Delay_reg_im(1);

  reduced_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_C2ReIm_1_C2ReIm_A <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product_C2ReIm_1_C2ReIm_A <= Delay_out1_re;
      END IF;
    END IF;
  END PROCESS reduced_process;


  In3_re_signed <= signed(In3_re);

  In3_im_signed <= signed(In3_im);

  dataOut_re <= In3_re_signed;
  dataOut_im <= In3_im_signed;

  Conjugate_out1_re <= dataOut_re;
  conj_cast <= resize(dataOut_im, 17);
  conj_cast_1 <=  - (conj_cast);
  
  Conjugate_out1_im <= X"7FFF" WHEN (conj_cast_1(16) = '0') AND (conj_cast_1(15) /= '0') ELSE
      X"8000" WHEN (conj_cast_1(16) = '1') AND (conj_cast_1(15) /= '1') ELSE
      conj_cast_1(15 DOWNTO 0);

  Delay1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_reg_re <= (OTHERS => to_signed(16#0000#, 16));
      Delay1_reg_im <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_reg_im(0) <= Conjugate_out1_im;
        Delay1_reg_im(1) <= Delay1_reg_im(0);
        Delay1_reg_re(0) <= Conjugate_out1_re;
        Delay1_reg_re(1) <= Delay1_reg_re(0);
      END IF;
    END IF;
  END PROCESS Delay1_process;

  Delay1_out1_re <= Delay1_reg_re(1);
  Delay1_out1_im <= Delay1_reg_im(1);

  reduced_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_C2ReIm_1_C2ReIm_B <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product_C2ReIm_1_C2ReIm_B <= Delay_out1_im;
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  Product_Re_AC <= Product_C2ReIm_1_C2ReIm_A * Delay1_out1_re;

  Product_Re_AC_1 <= Product_Re_AC(29 DOWNTO 14);

  Product_Re_BD <= Product_C2ReIm_1_C2ReIm_B * Delay1_out1_im;

  Product_Re_BD_1 <= Product_Re_BD(29 DOWNTO 14);

  mulOutput <= Product_Re_AC_1 - Product_Re_BD_1;

  Product_Im_AD <= Product_C2ReIm_1_C2ReIm_A * Delay1_out1_im;

  Product_Im_AD_1 <= Product_Im_AD(29 DOWNTO 14);

  Product_Im_BC <= Product_C2ReIm_1_C2ReIm_B * Delay1_out1_re;

  Product_Im_BC_1 <= Product_Im_BC(29 DOWNTO 14);

  mulOutput_1 <= Product_Im_AD_1 + Product_Im_BC_1;

  Delay2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_out1_re <= to_signed(16#0000#, 16);
      Delay2_out1_im <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_out1_re <= mulOutput;
        Delay2_out1_im <= mulOutput_1;
      END IF;
    END IF;
  END PROCESS Delay2_process;


  
  Switch_out1_re <= Constant_out1_re WHEN Delay3_out1 = '0' ELSE
      Delay2_out1_re;
  
  Switch_out1_im <= Constant_out1_im WHEN Delay3_out1 = '0' ELSE
      Delay2_out1_im;

  Delay6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay6_reg_re <= (OTHERS => to_signed(16#0000#, 16));
      Delay6_reg_im <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay6_reg_im(0) <= Switch_out1_im;
        Delay6_reg_im(1 TO 2) <= Delay6_reg_im(0 TO 1);
        Delay6_reg_re(0) <= Switch_out1_re;
        Delay6_reg_re(1 TO 2) <= Delay6_reg_re(0 TO 1);
      END IF;
    END IF;
  END PROCESS Delay6_process;

  Delay6_out1_re <= Delay6_reg_re(2);
  Delay6_out1_im <= Delay6_reg_im(2);

  out_rsvd_2 <= reset_1;

  out_rsvd_3 <= In2;

  Delay_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_reg(0) <= out_rsvd_3;
        Delay_reg(2 DOWNTO 1) <= Delay_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay_1_process;

  Delay_out1 <= Delay_reg(2);

  Logical_Operator6_out1 <=  NOT out_rsvd_2;

  Delay9_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay9_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay9_out1 <= Logical_Operator6_out1;
      END IF;
    END IF;
  END PROCESS Delay9_process;


  Delay1_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_reg(0) <= Logical_Operator6_out1;
        Delay1_reg(1) <= Delay1_reg(0);
      END IF;
    END IF;
  END PROCESS Delay1_1_process;

  Delay1_out1 <= Delay1_reg(1);

  Delay2_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_reg(0) <= Logical_Operator6_out1;
        Delay2_reg(2 DOWNTO 1) <= Delay2_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay2_1_process;

  Delay2_out1 <= Delay2_reg(2);

  Logical_Operator5_out1 <= Delay2_out1 AND (Delay1_out1 AND (Delay_out1 AND Delay9_out1));

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 3083
  count_step <= to_unsigned(16#0001#, 13);

  count_from <= to_unsigned(16#0000#, 13);

  count_reset <= to_unsigned(16#0000#, 13);

  numSCPS_unsigned <= unsigned(numSCPS);

  out_rsvd_4 <= numSCPS_unsigned;

  Delay10_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay10_reg <= (OTHERS => to_unsigned(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay10_reg(0) <= out_rsvd_4;
        Delay10_reg(1 TO 2) <= Delay10_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS Delay10_process;

  Delay10_out1 <= Delay10_reg(2);

  Data_Type_Conversion3_out1 <= resize(Delay10_out1, 17);

  Constant12_out1 <= to_unsigned(16#0000D#, 17);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 13
  count_step_1 <= to_unsigned(16#01#, 5);

  count_from_1 <= to_unsigned(16#00#, 5);

  count_reset_1 <= to_unsigned(16#00#, 5);

  count <= AvgSymbCount_out1 + count_step_1;

  
  need_to_wrap <= '1' WHEN AvgSymbCount_out1 = to_unsigned(16#0D#, 5) ELSE
      '0';

  
  count_value <= count WHEN need_to_wrap = '0' ELSE
      count_from_1;

  
  Compare_To_Constant1_out1 <= '1' WHEN AvgSymbCount_out1 = to_unsigned(16#00#, 5) ELSE
      '0';

  
  Compare_To_Constant4_out1 <= '1' WHEN SubScCount_out1 = to_unsigned(16#0000#, 13) ELSE
      '0';

  Logical_Operator5_out1_1 <= Compare_To_Constant1_out1 AND (Logical_Operator5_out1 AND Compare_To_Constant4_out1);

  whdlmod_c97_NumSCPerSym_Generator_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      numValidScPerSym <= to_unsigned(16#0000D#, 17);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        numValidScPerSym <= numValidScPerSym_next;
      END IF;
    END IF;
  END PROCESS whdlmod_c97_NumSCPerSym_Generator_process;

  whdlmod_c97_NumSCPerSym_Generator_output : PROCESS (Data_Type_Conversion3_out1, Logical_Operator5_out1_1, numValidScPerSym)
    VARIABLE sub_cast : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(18 DOWNTO 0);
    VARIABLE sub_temp : signed(18 DOWNTO 0);
    VARIABLE cast : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_1 : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_2 : signed(18 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(18 DOWNTO 0);
    VARIABLE cast_0 : unsigned(17 DOWNTO 0);
  BEGIN
    sub_temp := to_signed(16#00000#, 19);
    sub_temp_0 := to_signed(16#00000#, 19);
    sub_cast := to_unsigned(16#00000#, 18);
    sub_cast_0 := to_signed(16#00000#, 19);
    cast := to_unsigned(16#00000#, 18);
    sub_cast_1 := to_unsigned(16#00000#, 18);
    sub_cast_2 := to_signed(16#00000#, 19);
    cast_0 := to_unsigned(16#00000#, 18);
    numValidScPerSym_next <= numValidScPerSym;
    IF Logical_Operator5_out1_1 = '1' THEN 
      sub_cast := resize(Data_Type_Conversion3_out1, 18);
      sub_cast_0 := signed(resize(sub_cast, 19));
      sub_temp := sub_cast_0 - to_signed(16#00001#, 19);
      IF sub_temp(18) = '1' THEN 
        cast := "000000000000000000";
      ELSE 
        cast := unsigned(sub_temp(17 DOWNTO 0));
      END IF;
      IF cast(17) /= '0' THEN 
        numScPerSymOut <= "11111111111111111";
      ELSE 
        numScPerSymOut <= cast(16 DOWNTO 0);
      END IF;
      sub_cast_1 := resize(Data_Type_Conversion3_out1, 18);
      sub_cast_2 := signed(resize(sub_cast_1, 19));
      sub_temp_0 := sub_cast_2 - to_signed(16#00001#, 19);
      IF sub_temp_0(18) = '1' THEN 
        cast_0 := "000000000000000000";
      ELSE 
        cast_0 := unsigned(sub_temp_0(17 DOWNTO 0));
      END IF;
      IF cast_0(17) /= '0' THEN 
        numValidScPerSym_next <= "11111111111111111";
      ELSE 
        numValidScPerSym_next <= cast_0(16 DOWNTO 0);
      END IF;
    ELSE 
      numScPerSymOut <= numValidScPerSym;
    END IF;
  END PROCESS whdlmod_c97_NumSCPerSym_Generator_output;


  
  Compare_To_Constant5_out1 <= '1' WHEN numScPerSymOut > to_unsigned(16#00000#, 17) ELSE
      '0';

  
  Switch6_out1 <= Constant12_out1 WHEN Compare_To_Constant5_out1 = '0' ELSE
      numScPerSymOut;

  count_1 <= SubScCount_out1 + count_step;

  
  need_to_wrap_1 <= '1' WHEN SubScCount_out1 = to_unsigned(16#0C0B#, 13) ELSE
      '0';

  
  count_value_1 <= count_1 WHEN need_to_wrap_1 = '0' ELSE
      count_from;

  
  count_2 <= SubScCount_out1 WHEN Logical_Operator5_out1 = '0' ELSE
      count_value_1;

  Logical_Operator3_out1 <= AND_out1 OR out_rsvd_2;

  
  count_3 <= count_2 WHEN Logical_Operator3_out1 = '0' ELSE
      count_reset;

  SubScCount_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      SubScCount_out1 <= to_unsigned(16#0000#, 13);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        SubScCount_out1 <= count_3;
      END IF;
    END IF;
  END PROCESS SubScCount_process;


  
  Relational_Operator_relop1 <= '1' WHEN resize(SubScCount_out1, 17) >= Switch6_out1 ELSE
      '0';

  AND_out1 <= Relational_Operator_relop1 AND Logical_Operator5_out1;

  
  count_4 <= AvgSymbCount_out1 WHEN AND_out1 = '0' ELSE
      count_value;

  
  count_5 <= count_4 WHEN out_rsvd_2 = '0' ELSE
      count_reset_1;

  AvgSymbCount_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      AvgSymbCount_out1 <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        AvgSymbCount_out1 <= count_5;
      END IF;
    END IF;
  END PROCESS AvgSymbCount_process;


  ScCountDelay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ScCountDelay_out1 <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        ScCountDelay_out1 <= AvgSymbCount_out1;
      END IF;
    END IF;
  END PROCESS ScCountDelay_process;


  Constant11_out1 <= to_unsigned(16#01#, 5);

  Add3_out1 <= resize(ScCountDelay_out1, 6) + resize(Constant11_out1, 6);

  
  Compare_To_Constant_out1 <= '1' WHEN Add3_out1 = to_unsigned(16#0E#, 6) ELSE
      '0';

  Logical_Operator_out1_1 <=  NOT out_rsvd_2;

  dataDelay1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dataDelay1_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        dataDelay1_out1 <= Logical_Operator_out1_1;
      END IF;
    END IF;
  END PROCESS dataDelay1_process;


  dataDelay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dataDelay_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        dataDelay_out1 <= Logical_Operator5_out1;
      END IF;
    END IF;
  END PROCESS dataDelay_process;


  Logical_Operator4_out1 <= dataDelay1_out1 AND dataDelay_out1;

  Logical_Operator1_out1 <= Compare_To_Constant_out1 AND Logical_Operator4_out1;

  Delay4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay4_reg(0) <= Logical_Operator1_out1;
        Delay4_reg(2 DOWNTO 1) <= Delay4_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay4_process;

  Delay4_out1 <= Delay4_reg(2);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_out1_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay4_out1_1 <= Delay4_out1;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  Constant_out1_re_1 <= to_signed(16#00000000#, 29);
  Constant_out1_im_1 <= to_signed(16#00000000#, 29);

  Constant_out1_dtc_re <= Constant_out1_re_1(15 DOWNTO 0);
  Constant_out1_dtc_im <= Constant_out1_im_1(15 DOWNTO 0);

  out_rsvd_5 <= reset_1;

  Logical_Operator6_out1_1 <=  NOT out_rsvd_5;

  Delay9_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay9_out1_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay9_out1_1 <= Logical_Operator6_out1_1;
      END IF;
    END IF;
  END PROCESS Delay9_1_process;


  delayMatch_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay9_out1_2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay9_out1_2 <= Delay9_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch_1_process;


  Delay1_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_reg_1(0) <= Logical_Operator6_out1_1;
        Delay1_reg_1(1) <= Delay1_reg_1(0);
      END IF;
    END IF;
  END PROCESS Delay1_2_process;

  Delay1_out1_1 <= Delay1_reg_1(1);

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_out1_2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_out1_2 <= Delay1_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch1_process;


  Delay2_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_reg_1(0) <= Logical_Operator6_out1_1;
        Delay2_reg_1(2 DOWNTO 1) <= Delay2_reg_1(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay2_2_process;

  Delay2_out1_1 <= Delay2_reg_1(2);

  delayMatch2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_out1_2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_out1_2 <= Delay2_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch2_process;


  Logical_Operator5_out1_2 <= Delay2_out1_2 AND (Delay1_out1_2 AND (Delay3_out1 AND Delay9_out1_2));

  Delay2_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_out1_3 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_out1_3 <= Logical_Operator5_out1_2;
      END IF;
    END IF;
  END PROCESS Delay2_3_process;


  Constant2_out1_re <= to_signed(16#00000000#, 29);
  Constant2_out1_im <= to_signed(16#00000000#, 29);

  -- double(numOFDMSymToBeAvg)-1; %
  -- Embedded FI
  dataOut_re_1 <= resize(Switch_out1_re, 29);
  dataOut_im_1 <= resize(Switch_out1_im, 29);

  Delay4_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_out1_re <= to_signed(16#00000000#, 29);
      Delay4_out1_im <= to_signed(16#00000000#, 29);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay4_out1_re <= dataOut_re_1;
        Delay4_out1_im <= dataOut_im_1;
      END IF;
    END IF;
  END PROCESS Delay4_1_process;


  
  Switch_out1_re_1 <= Constant2_out1_re WHEN Delay2_out1_3 = '0' ELSE
      Delay4_out1_re;
  
  Switch_out1_im_1 <= Constant2_out1_im WHEN Delay2_out1_3 = '0' ELSE
      Delay4_out1_im;

  
  Compare_To_Constant3_out1 <= '1' WHEN ScCountDelay_out1 = to_unsigned(16#00#, 5) ELSE
      '0';

  Logical_Operator2_out1 <= Logical_Operator4_out1 AND Compare_To_Constant3_out1;

  reduced_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      SCAndSymb_Indicator_out2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        SCAndSymb_Indicator_out2 <= Logical_Operator2_out1;
      END IF;
    END IF;
  END PROCESS reduced_2_process;


  Delay1_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_out1_3 <= to_unsigned(16#0000#, 13);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_out1_3 <= SubScCount_out1;
      END IF;
    END IF;
  END PROCESS Delay1_3_process;


  reduced_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_out1_4 <= to_unsigned(16#0000#, 13);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_out1_4 <= Delay1_out1_3;
      END IF;
    END IF;
  END PROCESS reduced_3_process;


  Delay5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay5_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay5_out1 <= Logical_Operator5_out1;
      END IF;
    END IF;
  END PROCESS Delay5_process;


  delayMatch_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dataValidDelay <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        dataValidDelay <= Delay5_out1;
      END IF;
    END IF;
  END PROCESS delayMatch_2_process;


  Logical_Operator_out1_2 <= dataValidDelay AND Delay2_out1_3;

  Constant13_out1 <= '1';

  
  Switch8_out1 <= Logical_Operator_out1_2 WHEN SCAndSymb_Indicator_out2 = '0' ELSE
      Constant13_out1;

  reduced_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      SCAndSymb_Indicator_out1 <= to_unsigned(16#0000#, 13);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        SCAndSymb_Indicator_out1 <= SubScCount_out1;
      END IF;
    END IF;
  END PROCESS reduced_4_process;


  Constant1_out1_re_1 <= to_signed(16#00000000#, 29);
  Constant1_out1_im_1 <= to_signed(16#00000000#, 29);

  Accumulator_RAM_out1_im_signed <= signed(Accumulator_RAM_out1_im);

  Accumulator_RAM_out1_re_signed <= signed(Accumulator_RAM_out1_re);

  
  Switch7_out1_re <= Accumulator_RAM_out1_re_signed WHEN SCAndSymb_Indicator_out2 = '0' ELSE
      Constant1_out1_re_1;
  
  Switch7_out1_im <= Accumulator_RAM_out1_im_signed WHEN SCAndSymb_Indicator_out2 = '0' ELSE
      Constant1_out1_im_1;

  Add_out1_re_1 <= Switch_out1_re_1 + Switch7_out1_re;
  Add_out1_im_1 <= Switch_out1_im_1 + Switch7_out1_im;

  Delay1_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_reg_re_1 <= (OTHERS => to_signed(16#00000000#, 29));
      Delay1_reg_im_1 <= (OTHERS => to_signed(16#00000000#, 29));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_reg_im_1(0) <= Add_out1_im_1;
        Delay1_reg_im_1(1) <= Delay1_reg_im_1(0);
        Delay1_reg_re_1(0) <= Add_out1_re_1;
        Delay1_reg_re_1(1) <= Delay1_reg_re_1(0);
      END IF;
    END IF;
  END PROCESS Delay1_4_process;

  Delay1_out1_re_1 <= Delay1_reg_re_1(1);
  Delay1_out1_im_1 <= Delay1_reg_im_1(1);

  Constant1_out1_1 <= to_unsigned(16#000#, 12);

  Constant_out1_1 <= to_unsigned(16#001#, 12);

  
  Switch2_out1 <= Constant1_out1_1 WHEN Delay2_out1_3 = '0' ELSE
      Constant_out1_1;

  Constant2_out1 <= to_unsigned(16#0#, 4);

  Counter_RAM_out1_unsigned <= unsigned(Counter_RAM_out1);

  
  Switch3_out1 <= Counter_RAM_out1_unsigned WHEN SCAndSymb_Indicator_out2 = '0' ELSE
      Constant2_out1;

  Add2_out1 <= resize(Switch2_out1, 4) + Switch3_out1;

  whdlmod_c92_MUL_LUT_output : PROCESS (Add2_out1)
  BEGIN
    IF Add2_out1 = to_unsigned(16#1#, 4) THEN 
      Out_value <= to_unsigned(16#10000#, 17);
    ELSIF Add2_out1 = to_unsigned(16#2#, 4) THEN 
      Out_value <= to_unsigned(16#08000#, 17);
    ELSIF Add2_out1 = to_unsigned(16#3#, 4) THEN 
      Out_value <= to_unsigned(16#05555#, 17);
    ELSIF Add2_out1 = to_unsigned(16#4#, 4) THEN 
      Out_value <= to_unsigned(16#04000#, 17);
    ELSIF Add2_out1 = to_unsigned(16#5#, 4) THEN 
      Out_value <= to_unsigned(16#03333#, 17);
    ELSIF Add2_out1 = to_unsigned(16#6#, 4) THEN 
      Out_value <= to_unsigned(16#02AAA#, 17);
    ELSIF Add2_out1 = to_unsigned(16#7#, 4) THEN 
      Out_value <= to_unsigned(16#02492#, 17);
    ELSIF Add2_out1 = to_unsigned(16#8#, 4) THEN 
      Out_value <= to_unsigned(16#02000#, 17);
    ELSIF Add2_out1 = to_unsigned(16#9#, 4) THEN 
      Out_value <= to_unsigned(16#01C71#, 17);
    ELSIF Add2_out1 = to_unsigned(16#A#, 4) THEN 
      Out_value <= to_unsigned(16#01999#, 17);
    ELSIF Add2_out1 = to_unsigned(16#B#, 4) THEN 
      Out_value <= to_unsigned(16#01745#, 17);
    ELSIF Add2_out1 = to_unsigned(16#C#, 4) THEN 
      Out_value <= to_unsigned(16#01555#, 17);
    ELSIF Add2_out1 = to_unsigned(16#D#, 4) THEN 
      Out_value <= to_unsigned(16#013B1#, 17);
    ELSIF Add2_out1 = to_unsigned(16#E#, 4) THEN 
      Out_value <= to_unsigned(16#01249#, 17);
    ELSE 
      Out_value <= to_unsigned(16#10000#, 17);
    END IF;
  END PROCESS whdlmod_c92_MUL_LUT_output;


  Delay2_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_reg_2 <= (OTHERS => to_unsigned(16#00000#, 17));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_reg_2(0) <= Out_value;
        Delay2_reg_2(1) <= Delay2_reg_2(0);
      END IF;
    END IF;
  END PROCESS Delay2_4_process;

  Delay2_out1_4 <= Delay2_reg_2(1);

  Product1_cast <= signed(resize(Delay2_out1_4, 18));
  Product1_mul_temp <= Delay1_out1_re_1 * Product1_cast;
  Product1_Re <= Product1_mul_temp(45 DOWNTO 0);

  Product1_Re_1 <= Product1_Re(44 DOWNTO 16);

  Product11_cast <= signed(resize(Delay2_out1_4, 18));
  Product11_mul_temp <= Delay1_out1_im_1 * Product11_cast;
  Product1_Im <= Product11_mul_temp(45 DOWNTO 0);

  Product1_Im_1 <= Product1_Im(44 DOWNTO 16);

  Delay3_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay3_out1_re <= to_signed(16#00000000#, 29);
      Delay3_out1_im <= to_signed(16#00000000#, 29);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay3_out1_re <= Product1_Re_1;
        Delay3_out1_im <= Product1_Im_1;
      END IF;
    END IF;
  END PROCESS Delay3_1_process;


  Delay3_out1_dtc_re <= Delay3_out1_re(15 DOWNTO 0);
  Delay3_out1_dtc_im <= Delay3_out1_im(15 DOWNTO 0);

  
  Switch_out1_re_2 <= Constant_out1_dtc_re WHEN Delay4_out1_1 = '0' ELSE
      Delay3_out1_dtc_re;
  
  Switch_out1_im_2 <= Constant_out1_dtc_im WHEN Delay4_out1_1 = '0' ELSE
      Delay3_out1_dtc_im;

  
  Switch_out1_re_3 <= Delay6_out1_re WHEN Constant_out1 = '0' ELSE
      Switch_out1_re_2;
  
  Switch_out1_im_3 <= Delay6_out1_im WHEN Constant_out1 = '0' ELSE
      Switch_out1_im_2;

  Delay4_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_reg_re <= (OTHERS => to_signed(16#0000#, 16));
      Delay4_reg_im <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay4_reg_im(0) <= Switch_out1_im_3;
        Delay4_reg_im(1 TO 5) <= Delay4_reg_im(0 TO 4);
        Delay4_reg_re(0) <= Switch_out1_re_3;
        Delay4_reg_re(1 TO 5) <= Delay4_reg_re(0 TO 4);
      END IF;
    END IF;
  END PROCESS Delay4_2_process;

  Delay4_out1_re_1 <= Delay4_reg_re(5);
  Delay4_out1_im_1 <= Delay4_reg_im(5);

  Constant4_out1 <= '1';

  Delay3_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay3_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay3_reg_1(0) <= Logical_Operator5_out1;
        Delay3_reg_1(2 DOWNTO 1) <= Delay3_reg_1(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay3_2_process;

  Delay3_out1_1 <= Delay3_reg_1(2);

  
  Switch4_out1 <= Delay3_out1_1 WHEN Constant4_out1 = '0' ELSE
      Delay4_out1;

  out_rsvd_6 <= reset_1;

  Logical_Operator6_out1_2 <=  NOT out_rsvd_6;

  Delay9_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay9_out1_3 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay9_out1_3 <= Logical_Operator6_out1_2;
      END IF;
    END IF;
  END PROCESS Delay9_2_process;


  Delay1_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_reg_2 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_reg_2(0) <= Logical_Operator6_out1_2;
        Delay1_reg_2(1) <= Delay1_reg_2(0);
      END IF;
    END IF;
  END PROCESS Delay1_5_process;

  Delay1_out1_5 <= Delay1_reg_2(1);

  Delay2_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_reg_3 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_reg_3(0) <= Logical_Operator6_out1_2;
        Delay2_reg_3(2 DOWNTO 1) <= Delay2_reg_3(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay2_5_process;

  Delay2_out1_5 <= Delay2_reg_3(2);

  Logical_Operator5_out1_3 <= Delay2_out1_5 AND (Delay1_out1_5 AND (Switch4_out1 AND Delay9_out1_3));

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 3083
  count_step_2 <= to_unsigned(16#0001#, 13);

  count_from_2 <= to_unsigned(16#0000#, 13);

  count_reset_2 <= to_unsigned(16#0000#, 13);

  Constant5_out1 <= '1';

  Constant1_out1_2 <= to_unsigned(16#00001#, 17);

  Add1_out1 <= resize(Switch6_out1, 12) + resize(Constant1_out1_2, 12);

  Delay9_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay9_reg <= (OTHERS => to_unsigned(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay9_reg(0) <= Delay10_out1;
        Delay9_reg(1 TO 2) <= Delay9_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS Delay9_3_process;

  Delay9_out1_4 <= Delay9_reg(2);

  Delay8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay8_reg <= (OTHERS => to_unsigned(16#000#, 12));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay8_reg(0) <= Add1_out1;
        Delay8_reg(1 TO 2) <= Delay8_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS Delay8_process;

  Delay8_out1 <= Delay8_reg(2);

  Delay8_out1_dtc <= resize(Delay8_out1, 16);

  
  Switch5_out1 <= Delay9_out1_4 WHEN Constant5_out1 = '0' ELSE
      Delay8_out1_dtc;

  Data_Type_Conversion3_out1_1 <= resize(Switch5_out1, 17);

  Constant12_out1_1 <= to_unsigned(16#00019#, 17);

  count_6 <= numSCPS_Counter_out1 + count_step_2;

  
  need_to_wrap_2 <= '1' WHEN numSCPS_Counter_out1 = to_unsigned(16#0C0B#, 13) ELSE
      '0';

  
  count_value_2 <= count_6 WHEN need_to_wrap_2 = '0' ELSE
      count_from_2;

  
  count_7 <= numSCPS_Counter_out1 WHEN Logical_Operator5_out1_3 = '0' ELSE
      count_value_2;

  Add1_sub_cast <= signed(resize(Switch6_out1_1, 18));
  Add1_sub_cast_1 <= signed(resize(numSCPS_Counter_out1, 18));
  Add1_out1_1 <= Add1_sub_cast - Add1_sub_cast_1;

  
  Compare_To_Constant3_out1_1 <= '1' WHEN Add1_out1_1 = to_signed(16#00000#, 18) ELSE
      '0';

  Logical_Operator2_out1_1 <= Compare_To_Constant3_out1_1 AND Logical_Operator5_out1_3;

  Logical_Operator4_out1_1 <= Logical_Operator2_out1_1 OR out_rsvd_6;

  
  count_8 <= count_7 WHEN Logical_Operator4_out1_1 = '0' ELSE
      count_reset_2;

  numSCPS_Counter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      numSCPS_Counter_out1 <= to_unsigned(16#0000#, 13);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        numSCPS_Counter_out1 <= count_8;
      END IF;
    END IF;
  END PROCESS numSCPS_Counter_process;


  
  Compare_To_Zero1_out1 <= '1' WHEN numSCPS_Counter_out1 = to_unsigned(16#0000#, 13) ELSE
      '0';

  Logical_Operator5_out1_4 <= Logical_Operator5_out1_3 AND Compare_To_Zero1_out1;

  whdlmod_c99_NumSCPerSym_Generator_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      numValidScPerSym_1 <= to_unsigned(16#00019#, 17);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        numValidScPerSym_1 <= numValidScPerSym_next_1;
      END IF;
    END IF;
  END PROCESS whdlmod_c99_NumSCPerSym_Generator_process;

  whdlmod_c99_NumSCPerSym_Generator_output : PROCESS (Data_Type_Conversion3_out1_1, Logical_Operator5_out1_4, numValidScPerSym_1)
    VARIABLE sub_cast1 : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_01 : signed(18 DOWNTO 0);
    VARIABLE sub_temp1 : signed(18 DOWNTO 0);
    VARIABLE cast1 : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_11 : unsigned(17 DOWNTO 0);
    VARIABLE sub_cast_21 : signed(18 DOWNTO 0);
    VARIABLE sub_temp_01 : signed(18 DOWNTO 0);
    VARIABLE cast_01 : unsigned(17 DOWNTO 0);
  BEGIN
    sub_temp1 := to_signed(16#00000#, 19);
    sub_temp_01 := to_signed(16#00000#, 19);
    sub_cast1 := to_unsigned(16#00000#, 18);
    sub_cast_01 := to_signed(16#00000#, 19);
    cast1 := to_unsigned(16#00000#, 18);
    sub_cast_11 := to_unsigned(16#00000#, 18);
    sub_cast_21 := to_signed(16#00000#, 19);
    cast_01 := to_unsigned(16#00000#, 18);
    numValidScPerSym_next_1 <= numValidScPerSym_1;
    IF Logical_Operator5_out1_4 = '1' THEN 
      sub_cast1 := resize(Data_Type_Conversion3_out1_1, 18);
      sub_cast_01 := signed(resize(sub_cast1, 19));
      sub_temp1 := sub_cast_01 - to_signed(16#00001#, 19);
      IF sub_temp1(18) = '1' THEN 
        cast1 := "000000000000000000";
      ELSE 
        cast1 := unsigned(sub_temp1(17 DOWNTO 0));
      END IF;
      IF cast1(17) /= '0' THEN 
        numValidScPerSym_next_1 <= "11111111111111111";
      ELSE 
        numValidScPerSym_next_1 <= cast1(16 DOWNTO 0);
      END IF;
      sub_cast_11 := resize(Data_Type_Conversion3_out1_1, 18);
      sub_cast_21 := signed(resize(sub_cast_11, 19));
      sub_temp_01 := sub_cast_21 - to_signed(16#00001#, 19);
      IF sub_temp_01(18) = '1' THEN 
        cast_01 := "000000000000000000";
      ELSE 
        cast_01 := unsigned(sub_temp_01(17 DOWNTO 0));
      END IF;
      IF cast_01(17) /= '0' THEN 
        numScPerSymOut_1 <= "11111111111111111";
      ELSE 
        numScPerSymOut_1 <= cast_01(16 DOWNTO 0);
      END IF;
    ELSE 
      numScPerSymOut_1 <= numValidScPerSym_1;
    END IF;
  END PROCESS whdlmod_c99_NumSCPerSym_Generator_output;


  Delay_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_out1_1 <= to_unsigned(16#00000#, 17);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_out1_1 <= numScPerSymOut_1;
      END IF;
    END IF;
  END PROCESS Delay_2_process;


  
  Compare_To_Constant5_out1_1 <= '1' WHEN Delay_out1_1 > to_unsigned(16#00000#, 17) ELSE
      '0';

  
  Switch6_out1_1 <= Constant12_out1_1 WHEN Compare_To_Constant5_out1_1 = '0' ELSE
      Delay_out1_1;

  delayMatch_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      numScPerSym <= to_unsigned(16#00000#, 17);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        numScPerSym <= Switch6_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch_3_process;


  stateControl_1 <= '1';

  delayMatch4_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_2 <= stateControl_1;
      END IF;
    END IF;
  END PROCESS delayMatch4_1_process;


  enb_gated <= stateControl_2 AND enb;

  reduced_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Data_Valid_Reset_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Data_Valid_Reset_out1 <= Logical_Operator5_out1_3;
      END IF;
    END IF;
  END PROCESS reduced_5_process;


  reduced_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      NumSCPerSym_Generator_out4 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        NumSCPerSym_Generator_out4 <= Logical_Operator4_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_6_process;


  Constant2_out1_1 <= '1';

  delayMatch1_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      AvgDone <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        AvgDone <= Logical_Operator1_out1;
      END IF;
    END IF;
  END PROCESS delayMatch1_1_process;


  
  Compare_To_Constant1_out1_1 <= '1' WHEN Add2_out1 > to_unsigned(16#0#, 4) ELSE
      '0';

  Logical_Operator3_out1_1 <= AvgDone AND Compare_To_Constant1_out1_1;

  Delay5_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay5_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay5_reg(0) <= Logical_Operator3_out1_1;
        Delay5_reg(2 DOWNTO 1) <= Delay5_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay5_1_process;

  Delay5_out1_1 <= Delay5_reg(2);

  Constant9_out1 <= '0';

  Delay7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay7_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay7_reg(0) <= Logical_Operator5_out1_2;
        Delay7_reg(2 DOWNTO 1) <= Delay7_reg(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay7_process;

  Delay7_out1 <= Delay7_reg(2);

  Constant8_out1 <= '1';

  
  Switch4_out1_1 <= Constant9_out1 WHEN Delay5_out1_1 = '0' ELSE
      Constant8_out1;

  
  Switch2_out1_1 <= Delay7_out1 WHEN Constant2_out1_1 = '0' ELSE
      Switch4_out1_1;

  Logical_Operator6_out1_3 <=  NOT out_rsvd_6;

  Delay9_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay9_out1_5 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay9_out1_5 <= Logical_Operator6_out1_3;
      END IF;
    END IF;
  END PROCESS Delay9_4_process;


  delayMatch_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay9_out1_6 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay9_out1_6 <= Delay9_out1_5;
      END IF;
    END IF;
  END PROCESS delayMatch_4_process;


  Delay1_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_reg_3 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_reg_3(0) <= Logical_Operator6_out1_3;
        Delay1_reg_3(1) <= Delay1_reg_3(0);
      END IF;
    END IF;
  END PROCESS Delay1_6_process;

  Delay1_out1_6 <= Delay1_reg_3(1);

  delayMatch1_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_out1_7 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_out1_7 <= Delay1_out1_6;
      END IF;
    END IF;
  END PROCESS delayMatch1_2_process;


  Delay2_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_reg_4 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_reg_4(0) <= Logical_Operator6_out1_3;
        Delay2_reg_4(2 DOWNTO 1) <= Delay2_reg_4(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay2_6_process;

  Delay2_out1_6 <= Delay2_reg_4(2);

  delayMatch2_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_out1_7 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_out1_7 <= Delay2_out1_6;
      END IF;
    END IF;
  END PROCESS delayMatch2_1_process;


  Logical_Operator5_out1_5 <= Delay2_out1_7 AND (Delay1_out1_7 AND (Switch2_out1_1 AND Delay9_out1_6));

  Constant4_out1_1 <= '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_3 <= '1';

  count_from_3 <= '0';

  count_reset_3 <= '0';

  count_9 <= first_bin_flag_indicator_out1 XOR count_step_3;

  
  need_to_wrap_3 <= '1' WHEN first_bin_flag_indicator_out1 = '1' ELSE
      '0';

  
  count_value_3 <= count_9 WHEN need_to_wrap_3 = '0' ELSE
      count_from_3;

  
  Compare_To_Zero_out1 <= '1' WHEN first_bin_flag_indicator_out1 = '0' ELSE
      '0';

  Logical_Operator_out1_3 <= Logical_Operator5_out1_5 AND (Compare_To_Zero_out1 AND Data_Valid_Reset_out1);

  
  Switch1_out1 <= Logical_Operator_out1_3 WHEN first_bin_flag_indicator_out1 = '0' ELSE
      Constant4_out1_1;

  
  count_10 <= first_bin_flag_indicator_out1 WHEN Switch1_out1 = '0' ELSE
      count_value_3;

  
  count_11 <= count_10 WHEN NumSCPerSym_Generator_out4 = '0' ELSE
      count_reset_3;

  first_bin_flag_indicator_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      first_bin_flag_indicator_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        first_bin_flag_indicator_out1 <= count_11;
      END IF;
    END IF;
  END PROCESS first_bin_flag_indicator_process;


  
  Switch2_out1_2 <= Logical_Operator_out1_3 WHEN first_bin_flag_indicator_out1 = '0' ELSE
      Data_Valid_Reset_out1;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_4 <= to_unsigned(16#1#, 2);

  count_from_4 <= to_unsigned(16#0#, 2);

  Constant5_out1_1 <= to_unsigned(16#1#, 2);

  count_reset_4 <= to_unsigned(16#0#, 2);

  count_12 <= InterpPointsSampCount_out1 + count_step_4;

  
  need_to_wrap_4 <= '1' WHEN InterpPointsSampCount_out1 = to_unsigned(16#1#, 2) ELSE
      '0';

  
  count_value_4 <= count_12 WHEN need_to_wrap_4 = '0' ELSE
      count_from_4;

  
  count_13 <= InterpPointsSampCount_out1 WHEN Switch2_out1_2 = '0' ELSE
      count_value_4;

  
  count_14 <= count_13 WHEN Logical_Operator_out1_3 = '0' ELSE
      Constant5_out1_1;

  
  count_15 <= count_14 WHEN NumSCPerSym_Generator_out4 = '0' ELSE
      count_reset_4;

  InterpPointsSampCount_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      InterpPointsSampCount_out1 <= to_unsigned(16#0#, 2);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        InterpPointsSampCount_out1 <= count_15;
      END IF;
    END IF;
  END PROCESS InterpPointsSampCount_process;


  
  Compare_To_Constant_out1_1 <= '1' WHEN InterpPointsSampCount_out1 = to_unsigned(16#0#, 2) ELSE
      '0';

  
  Switch3_out1_1 <= Logical_Operator_out1_3 WHEN first_bin_flag_indicator_out1 = '0' ELSE
      Compare_To_Constant_out1_1;

  Logical_Operator3_out1_2 <= Switch3_out1_1 AND Data_Valid_Reset_out1;

  
  Compare_To_Constant1_out1_2 <= '1' WHEN numSCPS_Counter_out1 = to_unsigned(16#0001#, 13) ELSE
      '0';

  Logical_Operator1_out1_1 <= Compare_To_Constant1_out1_2 AND Logical_Operator5_out1_3;

  delayMatch1_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      EndOfFirstBin <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        EndOfFirstBin <= Logical_Operator1_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch1_3_process;


  delayMatch2_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ScCounter <= to_unsigned(16#0000#, 13);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        ScCounter <= numSCPS_Counter_out1;
      END IF;
    END IF;
  END PROCESS delayMatch2_2_process;


  interpFacOut <= to_unsigned(16#02#, 5);

  delayMatch3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      interpFac <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        interpFac <= interpFacOut;
      END IF;
    END IF;
  END PROCESS delayMatch3_process;


  whdlmod_c102_InitExtrapData_Generator_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      posOfFirstHighRefBuff <= to_unsigned(16#0000#, 13);
      intermediateBuff_re <= to_signed(16#0000#, 16);
      intermediateBuff_im <= to_signed(16#0000#, 16);
      interInp1_re <= to_signed(16#0000#, 16);
      interInp1_im <= to_signed(16#0000#, 16);
      interInp2_re <= to_signed(16#0000#, 16);
      interInp2_im <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        posOfFirstHighRefBuff <= posOfFirstHighRefBuff_next;
        intermediateBuff_re <= intermediateBuff_next_re;
        intermediateBuff_im <= intermediateBuff_next_im;
        interInp1_re <= interInp1_next_re;
        interInp1_im <= interInp1_next_im;
        interInp2_re <= interInp2_next_re;
        interInp2_im <= interInp2_next_im;
      END IF;
    END IF;
  END PROCESS whdlmod_c102_InitExtrapData_Generator_process;

  whdlmod_c102_InitExtrapData_Generator_output : PROCESS (Data_Valid_Reset_out1, EndOfFirstBin, Logical_Operator3_out1_2,
       Logical_Operator_out1_3, ScCounter, Switch_out1_im_3, Switch_out1_re_3,
       interInp1_im, interInp1_re, interInp2_im, interInp2_re,
       intermediateBuff_im, intermediateBuff_re, interpFac,
       posOfFirstHighRefBuff)
    VARIABLE posOfFirstHighRef : unsigned(12 DOWNTO 0);
    VARIABLE endValue : unsigned(12 DOWNTO 0);
    VARIABLE tmpPosFirstRef : unsigned(12 DOWNTO 0);
    VARIABLE tmpInterBuff_re : signed(15 DOWNTO 0);
    VARIABLE tmpInterBuff_im : signed(15 DOWNTO 0);
    VARIABLE sub_cast2 : unsigned(5 DOWNTO 0);
    VARIABLE sub_cast_02 : signed(6 DOWNTO 0);
    VARIABLE sub_temp2 : signed(6 DOWNTO 0);
    VARIABLE add_cast : unsigned(5 DOWNTO 0);
    VARIABLE add_temp : unsigned(13 DOWNTO 0);
    VARIABLE sub_cast_12 : unsigned(5 DOWNTO 0);
    VARIABLE sub_cast_22 : signed(6 DOWNTO 0);
    VARIABLE sub_temp_02 : signed(6 DOWNTO 0);
    VARIABLE cast2 : unsigned(5 DOWNTO 0);
    VARIABLE cast_02 : unsigned(12 DOWNTO 0);
  BEGIN
    interInp1_next_re <= interInp1_re;
    interInp1_next_im <= interInp1_im;
    interInp2_next_re <= interInp2_re;
    interInp2_next_im <= interInp2_im;
    --interpFac = double(abs(floor(real(interpFac))));
    --interpFac = cast(0,'like',ScCounter);
    posOfFirstHighRef := to_unsigned(16#0000#, 13);
    initExtrapValidOut <= '0';
    IF Logical_Operator_out1_3 = '1' THEN 
      tmpPosFirstRef := ScCounter;
      tmpInterBuff_re := Switch_out1_re_3;
      tmpInterBuff_im := Switch_out1_im_3;
    ELSE 
      tmpPosFirstRef := posOfFirstHighRefBuff;
      tmpInterBuff_re := intermediateBuff_re;
      tmpInterBuff_im := intermediateBuff_im;
    END IF;
    posOfFirstHighRefBuff_next <= tmpPosFirstRef;
    intermediateBuff_next_re <= tmpInterBuff_re;
    intermediateBuff_next_im <= tmpInterBuff_im;
    IF ScCounter >= tmpPosFirstRef THEN 
      posOfFirstHighRef := tmpPosFirstRef;
    END IF;
    sub_cast2 := resize(interpFac, 6);
    sub_cast_02 := signed(resize(sub_cast2, 7));
    sub_temp2 := sub_cast_02 - to_signed(16#01#, 7);
    IF sub_temp2(6) = '1' THEN 
      add_cast := "000000";
    ELSE 
      add_cast := unsigned(sub_temp2(5 DOWNTO 0));
    END IF;
    add_temp := resize(add_cast, 14) + resize(posOfFirstHighRef, 14);
    IF add_temp(13) /= '0' THEN 
      endValue := "1111111111111";
    ELSE 
      endValue := add_temp(12 DOWNTO 0);
    END IF;
    sub_cast_12 := resize(interpFac, 6);
    sub_cast_22 := signed(resize(sub_cast_12, 7));
    sub_temp_02 := sub_cast_22 - to_signed(16#01#, 7);
    IF sub_temp_02(6) = '1' THEN 
      cast2 := "000000";
    ELSE 
      cast2 := unsigned(sub_temp_02(5 DOWNTO 0));
    END IF;
    cast_02 := resize(cast2, 13);
    IF (Data_Valid_Reset_out1 = '1' AND (ScCounter >= cast_02)) AND (ScCounter <= endValue) THEN 
      initExtrapValidOut <= '1';
    END IF;
    IF EndOfFirstBin = '1' THEN 
      Data2Out_re <= tmpInterBuff_re;
      Data2Out_im <= tmpInterBuff_im;
      interInp1_next_re <= tmpInterBuff_re;
      interInp1_next_im <= tmpInterBuff_im;
      interInp2_next_re <= tmpInterBuff_re;
      interInp2_next_im <= tmpInterBuff_im;
    ELSIF (Logical_Operator3_out1_2 AND ( NOT Logical_Operator_out1_3)) = '1' THEN 
      interInp1_next_re <= interInp2_re;
      interInp1_next_im <= interInp2_im;
      tmpInterBuff_re := interInp2_re;
      tmpInterBuff_im := interInp2_im;
      Data2Out_re <= Switch_out1_re_3;
      Data2Out_im <= Switch_out1_im_3;
      interInp2_next_re <= Switch_out1_re_3;
      interInp2_next_im <= Switch_out1_im_3;
    ELSE 
      tmpInterBuff_re := interInp1_re;
      tmpInterBuff_im := interInp1_im;
      Data2Out_re <= interInp2_re;
      Data2Out_im <= interInp2_im;
    END IF;
    Data1Out_re <= tmpInterBuff_re;
    Data1Out_im <= tmpInterBuff_im;
    posOfFirstHighRef_1 <= posOfFirstHighRef;
  END PROCESS whdlmod_c102_InitExtrapData_Generator_output;


  out3_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      initExtrapValidOut_last_value <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        initExtrapValidOut_last_value <= initExtrapValidOut_1;
      END IF;
    END IF;
  END PROCESS out3_bypass_process;


  
  initExtrapValidOut_1 <= initExtrapValidOut_last_value WHEN stateControl_2 = '0' ELSE
      initExtrapValidOut;

  stateControl_4 <= '1';

  delayMatch_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_5 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_5 <= stateControl_4;
      END IF;
    END IF;
  END PROCESS delayMatch_5_process;


  enb_gated_1 <= stateControl_5 AND enb;

  HDL_Counter_ctrl_const_out <= '1';

  HDL_Counter_ctrl_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HDL_Counter_ctrl_delay_out <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        HDL_Counter_ctrl_delay_out <= HDL_Counter_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS HDL_Counter_ctrl_delay_process;


  HDL_Counter_Initial_Val_out <= to_unsigned(16#1#, 3);

  Constant2_out1_2 <= '0';

  delayMatch2_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant2_out1_3 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant2_out1_3 <= Constant2_out1_2;
      END IF;
    END IF;
  END PROCESS delayMatch2_3_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_5 <= '1';

  count_from_5 <= '0';

  count_reset_5 <= '0';

  Logical_Operator_out1_4 <=  NOT Logical_Operator_out1_3;

  Constant5_out1_2 <= '1';

  delayMatch1_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant5_out1_3 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant5_out1_3 <= Constant5_out1_2;
      END IF;
    END IF;
  END PROCESS delayMatch1_4_process;


  Constant4_out1_2 <= '0';

  delayMatch_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant4_out1_3 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant4_out1_3 <= Constant4_out1_2;
      END IF;
    END IF;
  END PROCESS delayMatch_6_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = -1
  --  count to value  = 0
  count_step_6 <= to_unsigned(16#1#, 3);

  count_from_6 <= to_unsigned(16#1#, 3);

  Constant_out1_2 <= to_unsigned(16#1#, 3);

  count_reset_6 <= to_unsigned(16#1#, 3);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_7 <= to_unsigned(16#1#, 3);

  count_from_7 <= to_unsigned(16#0#, 3);

  count_reset_7 <= to_unsigned(16#0#, 3);

  count_16 <= HDL_Counter1_out1 + count_step_7;

  
  need_to_wrap_5 <= '1' WHEN HDL_Counter1_out1 = to_unsigned(16#1#, 3) ELSE
      '0';

  
  count_value_5 <= count_16 WHEN need_to_wrap_5 = '0' ELSE
      count_from_7;

  count_17 <= HDL_Counter_out1 - count_step_6;

  
  need_to_wrap_6 <= '1' WHEN HDL_Counter_out1 = to_unsigned(16#0#, 3) ELSE
      '0';

  
  count_value_6 <= count_17 WHEN need_to_wrap_6 = '0' ELSE
      count_from_6;

  
  Compare_To_Constant3_out1_2 <= '1' WHEN binary_counter_out1 = '1' ELSE
      '0';

  
  Compare_To_Constant2_out1 <= '1' WHEN HDL_Counter_out1 = to_unsigned(16#0#, 3) ELSE
      '0';

  Logical_Operator1_out1_2 <= Compare_To_Constant2_out1 AND Compare_To_Constant3_out1_2;

  
  Switch4_out1_2 <= Constant5_out1_3 WHEN Logical_Operator1_out1_2 = '0' ELSE
      Constant4_out1_3;

  
  Switch1_out1_1 <= Logical_Operator_out1_5 WHEN binary_counter_out1 = '0' ELSE
      Switch4_out1_2;

  
  count_18 <= HDL_Counter_out1 WHEN Switch1_out1_1 = '0' ELSE
      count_value_6;

  count_19 <= binary_counter_out1 XOR count_step_5;

  
  need_to_wrap_7 <= '1' WHEN binary_counter_out1 = '1' ELSE
      '0';

  
  count_value_7 <= count_19 WHEN need_to_wrap_7 = '0' ELSE
      count_from_5;

  
  Switch_out1 <= Logical_Operator_out1_5 WHEN binary_counter_out1 = '0' ELSE
      Constant2_out1_3;

  
  count_20 <= binary_counter_out1 WHEN Switch_out1 = '0' ELSE
      count_value_7;

  
  count_21 <= count_20 WHEN Logical_Operator6_out1_4 = '0' ELSE
      count_reset_5;

  binary_counter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      binary_counter_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        binary_counter_out1 <= count_21;
      END IF;
    END IF;
  END PROCESS binary_counter_process;


  
  Compare_To_Constant_out1_2 <= '1' WHEN binary_counter_out1 = '0' ELSE
      '0';

  Logical_Operator_out1_5 <= Logical_Operator_out1_4 AND (Compare_To_Constant_out1_2 AND Logical_Operator3_out1_2);

  
  count_22 <= count_18 WHEN Logical_Operator_out1_5 = '0' ELSE
      Constant_out1_2;

  
  count_23 <= count_22 WHEN Logical_Operator6_out1_4 = '0' ELSE
      count_reset_6;

  HDL_Counter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HDL_Counter_out <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        HDL_Counter_out <= count_23;
      END IF;
    END IF;
  END PROCESS HDL_Counter_process;


  
  HDL_Counter_out1 <= HDL_Counter_Initial_Val_out WHEN HDL_Counter_ctrl_delay_out = '0' ELSE
      HDL_Counter_out;

  
  Compare_To_Constant1_out1_3 <= '1' WHEN HDL_Counter_out1 > to_unsigned(16#0#, 3) ELSE
      '0';

  Logical_Operator2_out1_2 <= Compare_To_Constant1_out1_3 AND Switch1_out1_1;

  
  count_24 <= HDL_Counter1_out1 WHEN Logical_Operator2_out1_2 = '0' ELSE
      count_value_5;

  Logical_Operator6_out1_4 <= Compare_To_Constant5_out1_2 OR out_rsvd_6;

  
  count_25 <= count_24 WHEN Logical_Operator6_out1_4 = '0' ELSE
      count_reset_7;

  HDL_Counter1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HDL_Counter1_out1 <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        HDL_Counter1_out1 <= count_25;
      END IF;
    END IF;
  END PROCESS HDL_Counter1_process;


  
  Compare_To_Constant5_out1_2 <= '1' WHEN HDL_Counter1_out1 = to_unsigned(16#1#, 3) ELSE
      '0';

  Constant8_out1_1 <= '0';

  
  CmpIPF_out1 <= '1' WHEN Add1_out1_1 < to_signed(16#00002#, 18) ELSE
      '0';

  delayMatch5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      CmpIPF_out1_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        CmpIPF_out1_1 <= CmpIPF_out1;
      END IF;
    END IF;
  END PROCESS delayMatch5_process;


  
  Switch4_out1_3 <= Constant8_out1_1 WHEN Logical_Operator3_out1_2 = '0' ELSE
      CmpIPF_out1_1;

  Constant1_out1_3 <= '0';

  delayMatch_7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant1_out1_4 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant1_out1_4 <= Constant1_out1_3;
      END IF;
    END IF;
  END PROCESS delayMatch_7_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_8 <= '1';

  count_from_8 <= '0';

  count_reset_8 <= '0';

  count_26 <= binary_counter1_out1 XOR count_step_8;

  
  need_to_wrap_8 <= '1' WHEN binary_counter1_out1 = '1' ELSE
      '0';

  
  count_value_8 <= count_26 WHEN need_to_wrap_8 = '0' ELSE
      count_from_8;

  
  Compare_To_Constant4_out1_1 <= '1' WHEN binary_counter1_out1 = '0' ELSE
      '0';

  Logical_Operator3_out1_3 <= Compare_To_Constant4_out1_1 AND Switch4_out1_3;

  
  Switch3_out1_2 <= Logical_Operator3_out1_3 WHEN binary_counter1_out1 = '0' ELSE
      Constant1_out1_4;

  
  count_27 <= binary_counter1_out1 WHEN Switch3_out1_2 = '0' ELSE
      count_value_8;

  
  count_28 <= count_27 WHEN Logical_Operator6_out1_4 = '0' ELSE
      count_reset_8;

  binary_counter1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      binary_counter1_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        binary_counter1_out1 <= count_28;
      END IF;
    END IF;
  END PROCESS binary_counter1_process;


  
  Switch2_out1_3 <= Logical_Operator_out1_5 WHEN binary_counter_out1 = '0' ELSE
      Compare_To_Constant1_out1_3;

  Constant_out1_3 <= '0';

  delayMatch_8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant_out1_4 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant_out1_4 <= Constant_out1_3;
      END IF;
    END IF;
  END PROCESS delayMatch_8_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 3083
  count_step_9 <= to_unsigned(16#0001#, 13);

  count_from_9 <= to_unsigned(16#0000#, 13);

  count_reset_9 <= to_unsigned(16#0000#, 13);

  count_29 <= numSCPSOutCounter_out1 + count_step_9;

  
  need_to_wrap_9 <= '1' WHEN numSCPSOutCounter_out1 = to_unsigned(16#0C0B#, 13) ELSE
      '0';

  
  count_value_9 <= count_29 WHEN need_to_wrap_9 = '0' ELSE
      count_from_9;

  Add_sub_cast <= signed(resize(numScPerSym, 18));
  Add_sub_cast_1 <= signed(resize(numSCPSOutCounter_out1, 18));
  Add_out1 <= Add_sub_cast - Add_sub_cast_1;

  
  Compare_To_Constant6_out1 <= '1' WHEN Add_out1 >= to_signed(16#00000#, 18) ELSE
      '0';

  Logical_Operator4_out1_2 <= Compare_To_Constant6_out1 AND (Compare_To_Constant5_out1_2 AND binary_counter1_out1);

  whdlmod_c104_FinExtrapCtrl_Generator_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      FinalExtrapRepBuff <= to_signed(16#00000#, 18);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_1 = '1' THEN
        FinalExtrapRepBuff <= FinalExtrapRepBuff_next;
      END IF;
    END IF;
  END PROCESS whdlmod_c104_FinExtrapCtrl_Generator_process;

  whdlmod_c104_FinExtrapCtrl_Generator_output : PROCESS (Add_out1, FinalExtrapRepBuff, Logical_Operator4_out1_2)
    VARIABLE tmpDiff : signed(17 DOWNTO 0);
  BEGIN
    finalExtrapValidOut <= '0';
    IF Logical_Operator4_out1_2 = '1' THEN 
      tmpDiff := Add_out1;
    ELSE 
      tmpDiff := FinalExtrapRepBuff;
    END IF;
    FinalExtrapRepBuff_next <= tmpDiff;
    IF Add_out1 >= to_signed(16#00000#, 18) THEN 
      IF Add_out1 <= tmpDiff THEN 
        finalExtrapValidOut <= '1';
      END IF;
      IF Add_out1 = to_signed(16#00000#, 18) THEN 
        FinalExtrapRepBuff_next <= to_signed(16#00000#, 18);
      END IF;
    END IF;
  END PROCESS whdlmod_c104_FinExtrapCtrl_Generator_output;


  out0_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      finalExtrapValidOut_last_value <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_1 = '1' THEN
        finalExtrapValidOut_last_value <= finalExtrapValidOut_1;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  finalExtrapValidOut_1 <= finalExtrapValidOut_last_value WHEN stateControl_5 = '0' ELSE
      finalExtrapValidOut;

  finalExtrapValidOut_2 <= finalExtrapValidOut_1;

  Logical_Operator5_out1_6 <= finalExtrapValidOut_2 OR Switch2_out1_3;

  Logical_Operator2_out1_3 <= initExtrapValidOut_1 OR Logical_Operator5_out1_6;

  
  Switch1_out1_2 <= Logical_Operator2_out1_3 WHEN Compare_To_Constant3_out1_3 = '0' ELSE
      Constant_out1_4;

  
  count_30 <= numSCPSOutCounter_out1 WHEN Switch1_out1_2 = '0' ELSE
      count_value_9;

  Add1_sub_cast_2 <= signed(resize(numScPerSym, 18));
  Add1_sub_cast_3 <= signed(resize(numSCPSOutCounter_out1, 18));
  Add1_out1_2 <= Add1_sub_cast_2 - Add1_sub_cast_3;

  
  Compare_To_Constant3_out1_3 <= '1' WHEN Add1_out1_2 = to_signed(16#00000#, 18) ELSE
      '0';

  Logical_Operator3_out1_4 <= Compare_To_Constant3_out1_3 OR out_rsvd_6;

  
  count_31 <= count_30 WHEN Logical_Operator3_out1_4 = '0' ELSE
      count_reset_9;

  numSCPSOutCounter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      numSCPSOutCounter_out1 <= to_unsigned(16#0000#, 13);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        numSCPSOutCounter_out1 <= count_31;
      END IF;
    END IF;
  END PROCESS numSCPSOutCounter_process;


  out2_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      posOfFirstHighRef_last_value <= to_unsigned(16#0000#, 13);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        posOfFirstHighRef_last_value <= posOfFirstHighRef_2;
      END IF;
    END IF;
  END PROCESS out2_bypass_process;


  
  posOfFirstHighRef_2 <= posOfFirstHighRef_last_value WHEN stateControl_2 = '0' ELSE
      posOfFirstHighRef_1;

  Add_sub_cast_2 <= signed(resize(numSCPSOutCounter_out1, 14));
  Add_sub_cast_3 <= signed(resize(posOfFirstHighRef_2, 14));
  Add_out1_1 <= Add_sub_cast_2 - Add_sub_cast_3;

  stateControl_7 <= '1';

  delayMatch1_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_8 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_8 <= stateControl_7;
      END IF;
    END IF;
  END PROCESS delayMatch1_5_process;


  enb_gated_2 <= stateControl_8 AND enb;

  Delay1_7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_reg_4 <= (OTHERS => to_signed(16#0000#, 14));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_2 = '1' THEN
        Delay1_reg_4(0) <= Add_out1_1;
        Delay1_reg_4(1 TO 5) <= Delay1_reg_4(0 TO 4);
      END IF;
    END IF;
  END PROCESS Delay1_7_process;

  Delay1_out1_8 <= Delay1_reg_4(5);

  
  switch_compare_1 <= '1' WHEN Delay1_out1_8 > to_signed(16#0000#, 14) ELSE
      '0';

  Constant4_out1_re <= to_signed(16#0000#, 16);
  Constant4_out1_im <= to_signed(16#0000#, 16);

  delayMatch2_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant4_out1_re_1 <= to_signed(16#0000#, 16);
      Constant4_out1_im_1 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant4_out1_re_1 <= Constant4_out1_re;
        Constant4_out1_im_1 <= Constant4_out1_im;
      END IF;
    END IF;
  END PROCESS delayMatch2_4_process;


  out1_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Data2Out_last_value_re <= to_signed(16#0000#, 16);
      Data2Out_last_value_im <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        Data2Out_last_value_re <= Data2Out_re_1;
        Data2Out_last_value_im <= Data2Out_im_1;
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  Data2Out_re_1 <= Data2Out_last_value_re WHEN stateControl_2 = '0' ELSE
      Data2Out_re;
  
  Data2Out_im_1 <= Data2Out_last_value_im WHEN stateControl_2 = '0' ELSE
      Data2Out_im;

  
  Switch3_out1_re <= Constant4_out1_re_1 WHEN initExtrapValidOut_1 = '0' ELSE
      Data2Out_re_1;
  
  Switch3_out1_im <= Constant4_out1_im_1 WHEN initExtrapValidOut_1 = '0' ELSE
      Data2Out_im_1;

  stateControl_9 <= '1';

  delayMatch3_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_10 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_10 <= stateControl_9;
      END IF;
    END IF;
  END PROCESS delayMatch3_1_process;


  enb_gated_3 <= stateControl_10 AND enb;

  Delay2_7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_reg_re <= (OTHERS => to_signed(16#0000#, 16));
      Delay2_reg_im <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_3 = '1' THEN
        Delay2_reg_im(0) <= Switch3_out1_im;
        Delay2_reg_im(1 TO 5) <= Delay2_reg_im(0 TO 4);
        Delay2_reg_re(0) <= Switch3_out1_re;
        Delay2_reg_re(1 TO 5) <= Delay2_reg_re(0 TO 4);
      END IF;
    END IF;
  END PROCESS Delay2_7_process;

  Delay2_out1_re_1 <= Delay2_reg_re(5);
  Delay2_out1_im_1 <= Delay2_reg_im(5);

  
  Compare_To_Constant7_out1 <= '1' WHEN Add_out1 = to_signed(16#00000#, 18) ELSE
      '0';

  Logical_Operator7_out1 <= Compare_To_Constant7_out1 OR out_rsvd_6;

  Constant6_out1 <= '0';

  delayMatch1_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant6_out1_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant6_out1_1 <= Constant6_out1;
      END IF;
    END IF;
  END PROCESS delayMatch1_6_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_10 <= '1';

  count_from_10 <= '0';

  count_reset_10 <= '0';

  count_32 <= binary_counter2_out1 XOR count_step_10;

  
  need_to_wrap_10 <= '1' WHEN binary_counter2_out1 = '1' ELSE
      '0';

  
  count_value_10 <= count_32 WHEN need_to_wrap_10 = '0' ELSE
      count_from_10;

  
  Switch7_out1 <= Logical_Operator4_out1_2 WHEN binary_counter2_out1 = '0' ELSE
      Constant6_out1_1;

  
  count_33 <= binary_counter2_out1 WHEN Switch7_out1 = '0' ELSE
      count_value_10;

  
  count_34 <= count_33 WHEN Logical_Operator7_out1 = '0' ELSE
      count_reset_10;

  binary_counter2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      binary_counter2_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        binary_counter2_out1 <= count_34;
      END IF;
    END IF;
  END PROCESS binary_counter2_process;


  stateControl_12 <= '1';

  delayMatch2_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_13 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_13 <= stateControl_12;
      END IF;
    END IF;
  END PROCESS delayMatch2_5_process;


  enb_gated_4 <= stateControl_13 AND enb;

  Delay1_8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_reg_5 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_4 = '1' THEN
        Delay1_reg_5(0) <= binary_counter2_out1;
        Delay1_reg_5(5 DOWNTO 1) <= Delay1_reg_5(4 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay1_8_process;

  Delay1_out1_9 <= Delay1_reg_5(5);

  Constant3_out1_re <= to_signed(16#0000#, 16);
  Constant3_out1_im <= to_signed(16#0000#, 16);

  delayMatch3_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant3_out1_re_1 <= to_signed(16#0000#, 16);
      Constant3_out1_im_1 <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant3_out1_re_1 <= Constant3_out1_re;
        Constant3_out1_im_1 <= Constant3_out1_im;
      END IF;
    END IF;
  END PROCESS delayMatch3_2_process;


  
  Switch5_out1_re <= Constant3_out1_re_1 WHEN finalExtrapValidOut_1 = '0' ELSE
      Data2Out_re_1;
  
  Switch5_out1_im <= Constant3_out1_im_1 WHEN finalExtrapValidOut_1 = '0' ELSE
      Data2Out_im_1;

  stateControl_14 <= '1';

  delayMatch4_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_15 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_15 <= stateControl_14;
      END IF;
    END IF;
  END PROCESS delayMatch4_2_process;


  enb_gated_5 <= stateControl_15 AND enb;

  Delay4_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_reg_re_1 <= (OTHERS => to_signed(16#0000#, 16));
      Delay4_reg_im_1 <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_5 = '1' THEN
        Delay4_reg_im_1(0) <= Switch5_out1_im;
        Delay4_reg_im_1(1 TO 5) <= Delay4_reg_im_1(0 TO 4);
        Delay4_reg_re_1(0) <= Switch5_out1_re;
        Delay4_reg_re_1(1 TO 5) <= Delay4_reg_re_1(0 TO 4);
      END IF;
    END IF;
  END PROCESS Delay4_3_process;

  Delay4_out1_re_2 <= Delay4_reg_re_1(5);
  Delay4_out1_im_2 <= Delay4_reg_im_1(5);

  down_counter_ctrl_const_out <= '1';

  down_counter_ctrl_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      down_counter_ctrl_delay_out <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        down_counter_ctrl_delay_out <= down_counter_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS down_counter_ctrl_delay_process;


  down_counter_Initial_Val_out <= to_unsigned(16#1#, 3);

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = -1
  --  count to value  = 0
  count_step_11 <= to_unsigned(16#1#, 3);

  count_from_11 <= to_unsigned(16#1#, 3);

  count_reset_11 <= to_unsigned(16#1#, 3);

  count_35 <= down_counter_out1 - count_step_11;

  
  need_to_wrap_11 <= '1' WHEN down_counter_out1 = to_unsigned(16#0#, 3) ELSE
      '0';

  
  count_value_11 <= count_35 WHEN need_to_wrap_11 = '0' ELSE
      count_from_11;

  
  count_36 <= down_counter_out1 WHEN Switch2_out1_3 = '0' ELSE
      count_value_11;

  
  count_37 <= count_36 WHEN out_rsvd_6 = '0' ELSE
      count_reset_11;

  down_counter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      down_counter_out <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        down_counter_out <= count_37;
      END IF;
    END IF;
  END PROCESS down_counter_process;


  
  down_counter_out1 <= down_counter_Initial_Val_out WHEN down_counter_ctrl_delay_out = '0' ELSE
      down_counter_out;

  stateControl_16 <= '1';

  delayMatch_9_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_17 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_17 <= stateControl_16;
      END IF;
    END IF;
  END PROCESS delayMatch_9_process;


  enb_gated_6 <= stateControl_17 AND enb;

  Delay3_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay3_reg_2 <= (OTHERS => to_unsigned(16#0#, 3));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_6 = '1' THEN
        Delay3_reg_2(0) <= down_counter_out1;
        Delay3_reg_2(1) <= Delay3_reg_2(0);
      END IF;
    END IF;
  END PROCESS Delay3_3_process;

  Delay3_out1_2 <= Delay3_reg_2(1);

  out0_bypass_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Data1Out_last_value_re <= to_signed(16#0000#, 16);
      Data1Out_last_value_im <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        Data1Out_last_value_re <= Data1Out_re_1;
        Data1Out_last_value_im <= Data1Out_im_1;
      END IF;
    END IF;
  END PROCESS out0_bypass_1_process;


  
  Data1Out_re_1 <= Data1Out_last_value_re WHEN stateControl_2 = '0' ELSE
      Data1Out_re;
  
  Data1Out_im_1 <= Data1Out_last_value_im WHEN stateControl_2 = '0' ELSE
      Data1Out_im;

  stateControl_18 <= '1';

  delayMatch1_7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_19 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_19 <= stateControl_18;
      END IF;
    END IF;
  END PROCESS delayMatch1_7_process;


  enb_gated_7 <= stateControl_19 AND enb;

  Delay4_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_reg_re_2 <= (OTHERS => to_signed(16#0000#, 16));
      Delay4_reg_im_2 <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_7 = '1' THEN
        Delay4_reg_im_2(0) <= Data1Out_im_1;
        Delay4_reg_im_2(1) <= Delay4_reg_im_2(0);
        Delay4_reg_re_2(0) <= Data1Out_re_1;
        Delay4_reg_re_2(1) <= Delay4_reg_re_2(0);
      END IF;
    END IF;
  END PROCESS Delay4_4_process;

  Delay4_out1_re_3 <= Delay4_reg_re_2(1);
  Delay4_out1_im_3 <= Delay4_reg_im_2(1);

  Product_cast <= signed(resize(Delay3_out1_2, 4));
  Product_mul_temp <= Product_cast * Delay4_out1_re_3;
  Product_out1_re <= Product_mul_temp(18 DOWNTO 0);
  Product_cast_1 <= signed(resize(Delay3_out1_2, 4));
  Product_mul_temp_1 <= Product_cast_1 * Delay4_out1_im_3;
  Product_out1_im <= Product_mul_temp_1(18 DOWNTO 0);

  stateControl_20 <= '1';

  delayMatch2_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_21 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_21 <= stateControl_20;
      END IF;
    END IF;
  END PROCESS delayMatch2_6_process;


  enb_gated_8 <= stateControl_21 AND enb;

  Delay7_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay7_out1_re <= to_signed(16#00000#, 19);
      Delay7_out1_im <= to_signed(16#00000#, 19);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_8 = '1' THEN
        Delay7_out1_re <= Product_out1_re;
        Delay7_out1_im <= Product_out1_im;
      END IF;
    END IF;
  END PROCESS Delay7_1_process;


  stateControl_22 <= '1';

  delayMatch3_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_23 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_23 <= stateControl_22;
      END IF;
    END IF;
  END PROCESS delayMatch3_3_process;


  enb_gated_9 <= stateControl_23 AND enb;

  Delay5_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay5_reg_re <= (OTHERS => to_signed(16#0000#, 16));
      Delay5_reg_im <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_9 = '1' THEN
        Delay5_reg_im(0) <= Data2Out_im_1;
        Delay5_reg_im(1) <= Delay5_reg_im(0);
        Delay5_reg_re(0) <= Data2Out_re_1;
        Delay5_reg_re(1) <= Delay5_reg_re(0);
      END IF;
    END IF;
  END PROCESS Delay5_2_process;

  Delay5_out1_re <= Delay5_reg_re(1);
  Delay5_out1_im <= Delay5_reg_im(1);

  Constant1_out1_5 <= to_unsigned(16#1#, 3);

  delayMatch4_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant1_out1_6 <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant1_out1_6 <= Constant1_out1_5;
      END IF;
    END IF;
  END PROCESS delayMatch4_3_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  count_step_12 <= to_unsigned(16#1#, 3);

  count_from_12 <= to_unsigned(16#0#, 3);

  count_reset_12 <= to_unsigned(16#0#, 3);

  count_38 <= up_counter_out1 + count_step_12;

  
  need_to_wrap_12 <= '1' WHEN up_counter_out1 = to_unsigned(16#1#, 3) ELSE
      '0';

  
  count_value_12 <= count_38 WHEN need_to_wrap_12 = '0' ELSE
      count_from_12;

  
  count_39 <= up_counter_out1 WHEN Switch2_out1_3 = '0' ELSE
      count_value_12;

  
  count_40 <= count_39 WHEN out_rsvd_6 = '0' ELSE
      count_reset_12;

  up_counter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      up_counter_out1 <= to_unsigned(16#0#, 3);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        up_counter_out1 <= count_40;
      END IF;
    END IF;
  END PROCESS up_counter_process;


  Add1_out1_3 <= resize(Constant1_out1_6, 4) + resize(up_counter_out1, 4);

  stateControl_24 <= '1';

  delayMatch5_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_25 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_25 <= stateControl_24;
      END IF;
    END IF;
  END PROCESS delayMatch5_1_process;


  enb_gated_10 <= stateControl_25 AND enb;

  Delay6_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay6_reg <= (OTHERS => to_unsigned(16#0#, 4));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_10 = '1' THEN
        Delay6_reg(0) <= Add1_out1_3;
        Delay6_reg(1) <= Delay6_reg(0);
      END IF;
    END IF;
  END PROCESS Delay6_1_process;

  Delay6_out1 <= Delay6_reg(1);

  Product1_cast_1 <= signed(resize(Delay6_out1, 5));
  Product1_mul_temp_1 <= Delay5_out1_re * Product1_cast_1;
  Product1_out1_re <= Product1_mul_temp_1(19 DOWNTO 0);
  Product1_cast_2 <= signed(resize(Delay6_out1, 5));
  Product1_mul_temp_2 <= Delay5_out1_im * Product1_cast_2;
  Product1_out1_im <= Product1_mul_temp_2(19 DOWNTO 0);

  stateControl_26 <= '1';

  delayMatch6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_27 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_27 <= stateControl_26;
      END IF;
    END IF;
  END PROCESS delayMatch6_process;


  enb_gated_11 <= stateControl_27 AND enb;

  Delay8_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay8_out1_re <= to_signed(16#00000#, 20);
      Delay8_out1_im <= to_signed(16#00000#, 20);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_11 = '1' THEN
        Delay8_out1_re <= Product1_out1_re;
        Delay8_out1_im <= Product1_out1_im;
      END IF;
    END IF;
  END PROCESS Delay8_1_process;


  Add_add_cast <= resize(Delay7_out1_re, 21);
  Add_add_cast_1 <= resize(Delay8_out1_re, 21);
  Add_out1_re_2 <= Add_add_cast + Add_add_cast_1;
  Add_add_cast_2 <= resize(Delay7_out1_im, 21);
  Add_add_cast_3 <= resize(Delay8_out1_im, 21);
  Add_out1_im_2 <= Add_add_cast_2 + Add_add_cast_3;

  stateControl_29 <= '1';

  delayMatch7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_30 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_30 <= stateControl_29;
      END IF;
    END IF;
  END PROCESS delayMatch7_process;


  enb_gated_12 <= stateControl_30 AND enb;

  Delay_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_reg_re_1 <= (OTHERS => to_signed(16#000000#, 21));
      Delay_reg_im_1 <= (OTHERS => to_signed(16#000000#, 21));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_12 = '1' THEN
        Delay_reg_im_1(0) <= Add_out1_im_2;
        Delay_reg_im_1(1) <= Delay_reg_im_1(0);
        Delay_reg_re_1(0) <= Add_out1_re_2;
        Delay_reg_re_1(1) <= Delay_reg_re_1(0);
      END IF;
    END IF;
  END PROCESS Delay_3_process;

  Delay_out1_re_1 <= Delay_reg_re_1(1);
  Delay_out1_im_1 <= Delay_reg_im_1(1);

  Out_value_1 <= to_unsigned(16#08000#, 17);

  stateControl_31 <= '1';

  delayMatch8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_32 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_32 <= stateControl_31;
      END IF;
    END IF;
  END PROCESS delayMatch8_process;


  enb_gated_13 <= stateControl_32 AND enb;

  Delay2_8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_reg_5 <= (OTHERS => to_unsigned(16#00000#, 17));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_13 = '1' THEN
        Delay2_reg_5(0) <= Out_value_1;
        Delay2_reg_5(1 TO 4) <= Delay2_reg_5(0 TO 3);
      END IF;
    END IF;
  END PROCESS Delay2_8_process;

  Delay2_out1_8 <= Delay2_reg_5(4);

  Product2_cast <= signed(resize(Delay2_out1_8, 18));
  Product2_mul_temp <= Delay_out1_re_1 * Product2_cast;
  Product2_out1_re <= Product2_mul_temp(37 DOWNTO 0);
  Product2_cast_1 <= signed(resize(Delay2_out1_8, 18));
  Product2_mul_temp_1 <= Delay_out1_im_1 * Product2_cast_1;
  Product2_out1_im <= Product2_mul_temp_1(37 DOWNTO 0);

  stateControl_33 <= '1';

  delayMatch9_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_34 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_34 <= stateControl_33;
      END IF;
    END IF;
  END PROCESS delayMatch9_process;


  enb_gated_14 <= stateControl_34 AND enb;

  Delay1_9_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_out1_re_2 <= to_signed(0, 38);
      Delay1_out1_im_2 <= to_signed(0, 38);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_14 = '1' THEN
        Delay1_out1_re_2 <= Product2_out1_re;
        Delay1_out1_im_2 <= Product2_out1_im;
      END IF;
    END IF;
  END PROCESS Delay1_9_process;


  
  dataOut_re_2 <= X"7FFF" WHEN ((Delay1_out1_re_2(37) = '0') AND (Delay1_out1_re_2(36 DOWNTO 31) /= "000000")) OR ((Delay1_out1_re_2(37) = '0') AND (Delay1_out1_re_2(31 DOWNTO 16) = X"7FFF")) ELSE
      X"8000" WHEN (Delay1_out1_re_2(37) = '1') AND (Delay1_out1_re_2(36 DOWNTO 31) /= "111111") ELSE
      Delay1_out1_re_2(31 DOWNTO 16) + ('0' & Delay1_out1_re_2(15));
  
  dataOut_im_2 <= X"7FFF" WHEN ((Delay1_out1_im_2(37) = '0') AND (Delay1_out1_im_2(36 DOWNTO 31) /= "000000")) OR ((Delay1_out1_im_2(37) = '0') AND (Delay1_out1_im_2(31 DOWNTO 16) = X"7FFF")) ELSE
      X"8000" WHEN (Delay1_out1_im_2(37) = '1') AND (Delay1_out1_im_2(36 DOWNTO 31) /= "111111") ELSE
      Delay1_out1_im_2(31 DOWNTO 16) + ('0' & Delay1_out1_im_2(15));

  
  Switch6_out1_re <= dataOut_re_2 WHEN Delay1_out1_9 = '0' ELSE
      Delay4_out1_re_2;
  
  Switch6_out1_im <= dataOut_im_2 WHEN Delay1_out1_9 = '0' ELSE
      Delay4_out1_im_2;

  
  Switch_out1_re_4 <= Delay2_out1_re_1 WHEN switch_compare_1 = '0' ELSE
      Switch6_out1_re;
  
  Switch_out1_im_4 <= Delay2_out1_im_1 WHEN switch_compare_1 = '0' ELSE
      Switch6_out1_im;

  
  Switch1_out1_re <= Delay4_out1_re_1 WHEN Constant1_out1 = '0' ELSE
      Switch_out1_re_4;
  
  Switch1_out1_im <= Delay4_out1_im_1 WHEN Constant1_out1 = '0' ELSE
      Switch_out1_im_4;

  Out1_re <= std_logic_vector(Switch1_out1_re);

  Out1_im <= std_logic_vector(Switch1_out1_im);

  Constant3_out1 <= '1';

  Delay1_10_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_reg_6 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_reg_6(0) <= Logical_Operator5_out1_5;
        Delay1_reg_6(5 DOWNTO 1) <= Delay1_reg_6(4 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay1_10_process;

  Delay1_out1_10 <= Delay1_reg_6(5);

  stateControl_35 <= '1';

  delayMatch4_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      stateControl_36 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        stateControl_36 <= stateControl_35;
      END IF;
    END IF;
  END PROCESS delayMatch4_4_process;


  enb_gated_15 <= stateControl_36 AND enb;

  Delay4_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_15 = '1' THEN
        Delay4_reg_1(0) <= Logical_Operator2_out1_3;
        Delay4_reg_1(5 DOWNTO 1) <= Delay4_reg_1(4 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay4_5_process;

  Delay4_out1_2 <= Delay4_reg_1(5);

  
  Switch3_out1_3 <= Delay1_out1_10 WHEN Constant3_out1 = '0' ELSE
      Delay4_out1_2;

  Logical_Operator6_out1_5 <=  NOT out_rsvd_6;

  Delay9_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay9_out1_7 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay9_out1_7 <= Logical_Operator6_out1_5;
      END IF;
    END IF;
  END PROCESS Delay9_5_process;


  delayMatch_10_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay9_out1_8 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay9_out1_8 <= Delay9_out1_7;
      END IF;
    END IF;
  END PROCESS delayMatch_10_process;


  Delay1_11_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_reg_7 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_reg_7(0) <= Logical_Operator6_out1_5;
        Delay1_reg_7(1) <= Delay1_reg_7(0);
      END IF;
    END IF;
  END PROCESS Delay1_11_process;

  Delay1_out1_11 <= Delay1_reg_7(1);

  delayMatch1_8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_out1_12 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_out1_12 <= Delay1_out1_11;
      END IF;
    END IF;
  END PROCESS delayMatch1_8_process;


  Delay4_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_reg_2 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay4_reg_2(0) <= Logical_Operator6_out1_5;
        Delay4_reg_2(2 DOWNTO 1) <= Delay4_reg_2(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay4_6_process;

  Delay4_out1_3 <= Delay4_reg_2(2);

  delayMatch2_7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_out1_4 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay4_out1_4 <= Delay4_out1_3;
      END IF;
    END IF;
  END PROCESS delayMatch2_7_process;


  Delay6_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay6_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay6_reg_1(0) <= Logical_Operator6_out1_5;
        Delay6_reg_1(3 DOWNTO 1) <= Delay6_reg_1(2 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay6_2_process;

  Delay6_out1_1 <= Delay6_reg_1(3);

  delayMatch3_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay6_out1_2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay6_out1_2 <= Delay6_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch3_4_process;


  Delay7_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay7_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay7_reg_1(0) <= Logical_Operator6_out1_5;
        Delay7_reg_1(4 DOWNTO 1) <= Delay7_reg_1(3 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay7_2_process;

  Delay7_out1_1 <= Delay7_reg_1(4);

  delayMatch4_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay7_out1_2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay7_out1_2 <= Delay7_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch4_5_process;


  Delay8_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay8_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay8_reg_1(0) <= Logical_Operator6_out1_5;
        Delay8_reg_1(5 DOWNTO 1) <= Delay8_reg_1(4 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Delay8_2_process;

  Delay8_out1_1 <= Delay8_reg_1(5);

  delayMatch5_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay8_out1_2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay8_out1_2 <= Delay8_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch5_2_process;


  Logical_Operator5_out1_7 <= Delay8_out1_2 AND (Delay7_out1_2 AND (Delay6_out1_2 AND (Delay4_out1_4 AND (Delay1_out1_12 AND (Switch3_out1_3 AND Delay9_out1_8)))));

  Out2 <= Logical_Operator5_out1_7;

END rtl;

