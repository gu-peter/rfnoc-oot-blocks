-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/genhdlOFDMDemodulatorChEstModel/Demodulat_ip.vhd
-- Created: 2025-12-04 17:31:20
-- 
-- Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: -1
-- Target subsystem base rate: -1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Demodulat_ip
-- Source Path: Demodulat_ip
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Demodulat_ip_pkg.ALL;

ENTITY Demodulat_ip IS
  PORT( IPCORE_CLK                        :   IN    std_logic;  -- ufix1
        IPCORE_RESETN                     :   IN    std_logic;  -- ufix1
        AXIS_A_Master_TREADY              :   IN    std_logic;  -- ufix1
        AXIS_A_Slave_TDATA                :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
        AXIS_A_Slave_TVALID               :   IN    std_logic;  -- ufix1
        AXIS_A_Master_TDATA               :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32
        AXIS_A_Master_TVALID              :   OUT   std_logic;  -- ufix1
        AXIS_A_Master_TLAST               :   OUT   std_logic;  -- ufix1
        AXIS_A_Slave_TREADY               :   OUT   std_logic  -- ufix1
        );
END Demodulat_ip;


ARCHITECTURE rtl OF Demodulat_ip IS

  -- Component Declarations
  COMPONENT Demodulat_ip_reset_sync
    PORT( clk                             :   IN    std_logic;  -- ufix1
          reset_in                        :   IN    std_logic;  -- ufix1
          reset_out                       :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT Demodulat_ip_axis_a_slave
    PORT( clk                             :   IN    std_logic;  -- ufix1
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          AXIS_A_Slave_TDATA              :   IN    vector_of_std_logic_vector16(0 TO 1);  -- ufix16 [2]
          AXIS_A_Slave_TVALID             :   IN    std_logic;  -- ufix1
          auto_ready                      :   IN    std_logic;  -- ufix1
          AXIS_A_Slave_TREADY             :   OUT   std_logic;  -- ufix1
          user_data                       :   OUT   vector_of_std_logic_vector16(0 TO 1);  -- ufix16 [2]
          user_valid                      :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  COMPONENT Demodulat_ip_dut
    PORT( clk                             :   IN    std_logic;  -- ufix1
          reset                           :   IN    std_logic;
          dut_enable                      :   IN    std_logic;  -- ufix1
          In1_re                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          In1_im                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          In2                             :   IN    std_logic;  -- ufix1
          ce_out                          :   OUT   std_logic;  -- ufix1
          dataOut_re                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          dataOut_im                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          validOut                        :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  COMPONENT Demodulat_ip_axis_a_master
    PORT( clk                             :   IN    std_logic;  -- ufix1
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          AXIS_A_Master_TREADY            :   IN    std_logic;  -- ufix1
          user_data                       :   IN    vector_of_std_logic_vector16(0 TO 1);  -- ufix16 [2]
          user_valid                      :   IN    std_logic;  -- ufix1
          packet_size_axis_a_master       :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          AXIS_A_Master_TDATA             :   OUT   vector_of_std_logic_vector16(0 TO 1);  -- ufix16 [2]
          AXIS_A_Master_TVALID            :   OUT   std_logic;  -- ufix1
          AXIS_A_Master_TLAST             :   OUT   std_logic;  -- ufix1
          auto_ready                      :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Demodulat_ip_reset_sync
    USE ENTITY work.Demodulat_ip_reset_sync(rtl);

  FOR ALL : Demodulat_ip_axis_a_slave
    USE ENTITY work.Demodulat_ip_axis_a_slave(rtl);

  FOR ALL : Demodulat_ip_dut
    USE ENTITY work.Demodulat_ip_dut(rtl);

  FOR ALL : Demodulat_ip_axis_a_master
    USE ENTITY work.Demodulat_ip_axis_a_master(rtl);

  -- Signals
  SIGNAL reset                            : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL axi_enable                       : std_logic;  -- ufix1
  SIGNAL const_1_1                        : std_logic;  -- ufix1
  SIGNAL reset_cm                         : std_logic;  -- ufix1
  SIGNAL AXIS_A_Slave_TDATA_unsigned      : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL AXIS_A_Slave_TDATA_0             : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL AXIS_A_Slave_TDATA_1             : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL AXIS_A_Slave_TDATA_Vec           : vector_of_unsigned16(0 TO 1);  -- ufix16 [2]
  SIGNAL AXIS_A_Slave_TDATA_Vec_1         : vector_of_std_logic_vector16(0 TO 1);  -- ufix16 [2]
  SIGNAL const_packet_size_axis_a_master  : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL dataOut_im_sig                   : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dataOut_im_sig_signed            : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL top_user_data_1                  : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL top_user_data                    : vector_of_std_logic_vector16(0 TO 1);  -- ufix16 [2]
  SIGNAL top_user_data_1_1                : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL In1_im_sig                       : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL auto_ready_axis_a_master         : std_logic;  -- ufix1
  SIGNAL top_user_valid                   : std_logic;  -- ufix1
  SIGNAL top_user_data_0                  : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL In1_re_sig                       : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL auto_ready_dut_enb               : std_logic;  -- ufix1
  SIGNAL dut_enable                       : std_logic;  -- ufix1
  SIGNAL ce_out_sig                       : std_logic;  -- ufix1
  SIGNAL dataOut_re_sig                   : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL validOut_sig                     : std_logic;  -- ufix1
  SIGNAL dataOut_re_sig_signed            : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL top_user_data_0_1                : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL top_user_data_2                  : vector_of_unsigned16(0 TO 1);  -- ufix16 [2]
  SIGNAL top_user_data_3                  : vector_of_std_logic_vector16(0 TO 1);  -- ufix16 [2]
  SIGNAL AXIS_A_Master_TDATA_Vec          : vector_of_std_logic_vector16(0 TO 1);  -- ufix16 [2]
  SIGNAL AXIS_A_Master_TDATA_Vec_1        : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL AXIS_A_Master_TDATA_Vec_0        : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL AXIS_A_Master_TDATA_tmp          : unsigned(31 DOWNTO 0);  -- ufix32

BEGIN
  u_Demodulat_ip_reset_sync_inst : Demodulat_ip_reset_sync
    PORT MAP( clk => IPCORE_CLK,  -- ufix1
              reset_in => reset_cm,  -- ufix1
              reset_out => reset
              );

  u_Demodulat_ip_axis_a_slave_inst : Demodulat_ip_axis_a_slave
    PORT MAP( clk => IPCORE_CLK,  -- ufix1
              reset => reset,
              enb => const_1_1,
              AXIS_A_Slave_TDATA => AXIS_A_Slave_TDATA_Vec_1,  -- ufix16 [2]
              AXIS_A_Slave_TVALID => AXIS_A_Slave_TVALID,  -- ufix1
              auto_ready => auto_ready_axis_a_master,  -- ufix1
              AXIS_A_Slave_TREADY => AXIS_A_Slave_TREADY,  -- ufix1
              user_data => top_user_data,  -- ufix16 [2]
              user_valid => top_user_valid  -- ufix1
              );

  u_Demodulat_ip_dut_inst : Demodulat_ip_dut
    PORT MAP( clk => IPCORE_CLK,  -- ufix1
              reset => reset,
              dut_enable => dut_enable,  -- ufix1
              In1_re => std_logic_vector(In1_re_sig),  -- sfix16_En14
              In1_im => std_logic_vector(In1_im_sig),  -- sfix16_En14
              In2 => top_user_valid,  -- ufix1
              ce_out => ce_out_sig,  -- ufix1
              dataOut_re => dataOut_re_sig,  -- sfix16_En14
              dataOut_im => dataOut_im_sig,  -- sfix16_En14
              validOut => validOut_sig  -- ufix1
              );

  u_Demodulat_ip_axis_a_master_inst : Demodulat_ip_axis_a_master
    PORT MAP( clk => IPCORE_CLK,  -- ufix1
              reset => reset,
              enb => const_1_1,
              AXIS_A_Master_TREADY => AXIS_A_Master_TREADY,  -- ufix1
              user_data => top_user_data_3,  -- ufix16 [2]
              user_valid => validOut_sig,  -- ufix1
              packet_size_axis_a_master => std_logic_vector(const_packet_size_axis_a_master),  -- ufix32
              AXIS_A_Master_TDATA => AXIS_A_Master_TDATA_Vec,  -- ufix16 [2]
              AXIS_A_Master_TVALID => AXIS_A_Master_TVALID,  -- ufix1
              AXIS_A_Master_TLAST => AXIS_A_Master_TLAST,  -- ufix1
              auto_ready => auto_ready_axis_a_master  -- ufix1
              );

  axi_enable <= '1';

  const_1_1 <= '1';

  enb <= const_1_1;

  reset_cm <=  NOT IPCORE_RESETN;

  AXIS_A_Slave_TDATA_unsigned <= unsigned(AXIS_A_Slave_TDATA);

  AXIS_A_Slave_TDATA_0 <= AXIS_A_Slave_TDATA_unsigned(15 DOWNTO 0);

  AXIS_A_Slave_TDATA_1 <= AXIS_A_Slave_TDATA_unsigned(31 DOWNTO 16);

  AXIS_A_Slave_TDATA_Vec(0) <= AXIS_A_Slave_TDATA_0;
  AXIS_A_Slave_TDATA_Vec(1) <= AXIS_A_Slave_TDATA_1;

  outputgen1: FOR k IN 0 TO 1 GENERATE
    AXIS_A_Slave_TDATA_Vec_1(k) <= std_logic_vector(AXIS_A_Slave_TDATA_Vec(k));
  END GENERATE;

  const_packet_size_axis_a_master <= to_unsigned(1024, 32);

  dataOut_im_sig_signed <= signed(dataOut_im_sig);

  top_user_data_1 <= unsigned(dataOut_im_sig_signed);

  top_user_data_1_1 <= unsigned(top_user_data(1));

  In1_im_sig <= signed(top_user_data_1_1);

  top_user_data_0 <= unsigned(top_user_data(0));

  In1_re_sig <= signed(top_user_data_0);

  reg_process : PROCESS (IPCORE_CLK, reset)
  BEGIN
    IF reset = '1' THEN
      auto_ready_dut_enb <= '0';
    ELSIF IPCORE_CLK'EVENT AND IPCORE_CLK = '1' THEN
      IF enb = '1' THEN
        auto_ready_dut_enb <= auto_ready_axis_a_master;
      END IF;
    END IF;
  END PROCESS reg_process;


  dut_enable <= axi_enable AND auto_ready_dut_enb;

  dataOut_re_sig_signed <= signed(dataOut_re_sig);

  top_user_data_0_1 <= unsigned(dataOut_re_sig_signed);

  top_user_data_2(0) <= top_user_data_0_1;
  top_user_data_2(1) <= top_user_data_1;

  outputgen: FOR k IN 0 TO 1 GENERATE
    top_user_data_3(k) <= std_logic_vector(top_user_data_2(k));
  END GENERATE;

  AXIS_A_Master_TDATA_Vec_1 <= unsigned(AXIS_A_Master_TDATA_Vec(1));

  AXIS_A_Master_TDATA_Vec_0 <= unsigned(AXIS_A_Master_TDATA_Vec(0));

  AXIS_A_Master_TDATA_tmp <= AXIS_A_Master_TDATA_Vec_1 & AXIS_A_Master_TDATA_Vec_0;

  AXIS_A_Master_TDATA <= std_logic_vector(AXIS_A_Master_TDATA_tmp);

END rtl;

